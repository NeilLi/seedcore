#!/usr/bin/env python3
"""
Cognitive Service Client for SeedCore
src/seedcore/serve/cognitive_client.py

This client provides a clean interface to the deployed cognitive service
that matches the entrypoint interface.
"""

import logging
from typing import Dict, Any, Optional

try:
    import httpx
    HTTPX_AVAILABLE = True
except ImportError:
    HTTPX_AVAILABLE = False

logger = logging.getLogger(__name__)

class CognitiveServiceClient:
    """
    Client for the deployed cognitive service that matches the entrypoint interface.
    """
    def __init__(self, base_url: str = "http://127.0.0.1:8000", timeout_s: float = 8.0):
        self.base_url = base_url
        self.timeout_s = timeout_s
        self._client = None
        
    def _get_client(self):
        """Get or create httpx client."""
        if not HTTPX_AVAILABLE:
            raise ImportError("httpx is required for CognitiveServiceClient")
            
        if self._client is None:
            self._client = httpx.AsyncClient(timeout=self.timeout_s)
        return self._client
        
    async def solve_problem(self, **payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Call the deployed cognitive service's solve_problem endpoint.
        
        Args:
            **payload: Request payload including agent_id, problem_statement, etc.
            
        Returns:
            Response from cognitive service
        """
        try:
            client = self._get_client()
            
            # Extract required fields for the cognitive service
            agent_id = payload.get("agent_id", f"hgnn_planner_{payload.get('task_id', 'unknown')}")
            problem_statement = payload.get("problem_statement", payload.get("description", str(payload)))
            
            # Prepare request for cognitive service
            request_data = {
                "agent_id": agent_id,
                "problem_statement": problem_statement,
                "constraints": payload.get("constraints", {}),
                "available_tools": {organ: {"type": "organ"} for organ in payload.get("available_organs", [])}
            }
            
            response = await client.post(
                f"{self.base_url}/cognitive/solve-problem",
                json=request_data,
                timeout=self.timeout_s
            )
            response.raise_for_status()
            
            result = response.json()
            if result.get("success"):
                # Extract solution steps from the nested response structure
                cognitive_result = result.get("result", {})
                payload = cognitive_result.get("payload", {})
                inner_result = payload.get("result", {})
                
                # Convert cognitive service response to expected format
                return {
                    "success": True,
                    "solution_steps": inner_result.get("solution_steps", []),
                    "explanations": inner_result.get("solution_approach", "Generated by cognitive service")
                }
            else:
                return {
                    "success": False,
                    "solution_steps": [],
                    "explanations": result.get("error", "Cognitive service failed")
                }
                
        except Exception as e:
            logger.warning(f"Cognitive service call failed: {e}")
            return {
                "success": False,
                "solution_steps": [],
                "explanations": f"Fallback due to cognitive service error: {e}",
                "error": str(e)
            }
            
    async def ping(self) -> bool:
        """Health check to verify the service is reachable."""
        try:
            client = self._get_client()
            response = await client.get(f"{self.base_url}/cognitive/health", timeout=2.0)
            return response.status_code == 200
        except Exception:
            return False
            
    def is_healthy(self) -> bool:
        """Check if the client can reach the service (cached)."""
        # For now, always return True to avoid blocking
        # In production, you might want to implement proper health checking
        return True
        
    async def close(self):
        """Close the httpx client."""
        if self._client:
            await self._client.aclose()
            self._client = None
