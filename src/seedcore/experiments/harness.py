# Copyright 2024 SeedCore Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is auto-generated by create_seedcore_skeleton.py
"""
Synthetic experiment harness (Section 11).
Use to drive pair/hyper/entropy/mem sweeps and validate energy behavior.
"""

import asyncio
import logging
import numpy as np
import time
from typing import List, Dict, Any, Optional
from collections import deque

logger = logging.getLogger(__name__)

class EnergyValidationHarness:
    """
    Energy validation harness for synthetic workloads A-D.
    Implements the experimental framework described in the energy validation blueprint.
    """
    
    def __init__(self, organism_manager, energy_ledger):
        self.organism = organism_manager
        self.ledger = energy_ledger
        self.results = []
        self.experiment_history = {}
    
    async def experiment_A_pair(self):
        """Synthetic same-organ dual-agent tasks â†’ expect pair slope < 0."""
        logger.info("Running Experiment A: Pair Energy Validation")
        
        # Create synthetic tasks for same-organ agents
        cognitive_organ = self.organism.get_organ_handle("cognitive_organ_1")
        
        if not cognitive_organ:
            logger.error("Cognitive organ not found")
            return False
        
        experiment_results = []
        
        for i in range(50):
            task = {
                "type": "collaborative_reasoning",
                "complexity": 0.5 + 0.1 * i,
                "agents_required": 2,
                "description": f"Collaborative reasoning task {i}"
            }
            
            try:
                result = await cognitive_organ.run_task.remote(task)
                experiment_results.append({
                    "experiment": "A",
                    "step": i,
                    "energy": self.ledger.total,
                    "pair_energy": self.ledger.pair,
                    "task_complexity": task["complexity"],
                    "success": result.get("success", False)
                })
                
                # Small delay to allow energy updates
                await asyncio.sleep(0.1)
                
            except Exception as e:
                logger.error(f"Error in experiment A step {i}: {e}")
                continue
        
        # Calculate slope
        pair_energies = [r["pair_energy"] for r in experiment_results]
        pair_slope = self.calculate_slope(pair_energies)
        
        # Store results
        self.experiment_history["A"] = {
            "results": experiment_results,
            "pair_slope": pair_slope,
            "success": pair_slope < 0,
            "timestamp": time.time()
        }
        
        logger.info(f"Experiment A complete. Pair slope: {pair_slope:.4f}, Success: {pair_slope < 0}")
        return pair_slope < 0  # Should be negative
    
    async def experiment_B_hyper(self):
        """Force escalations across two organs to train hyper-edge weights."""
        logger.info("Running Experiment B: Hyper-Edge Validation")
        
        experiment_results = []
        
        for i in range(30):
            # Create cross-organ escalation task
            task = {
                "type": "cross_organ_escalation",
                "source_organ": "cognitive_organ_1",
                "target_organ": "actuator_organ_1",
                "complexity": 0.7,
                "precision": 0.3,
                "description": f"Cross-organ escalation {i}"
            }
            
            try:
                result = await self.organism.execute_task_on_organ("cognitive_organ_1", task)
                experiment_results.append({
                    "experiment": "B",
                    "step": i,
                    "energy": self.ledger.total,
                    "hyper_energy": self.ledger.hyper,
                    "complexity": task["complexity"],
                    "precision": task["precision"],
                    "success": result.get("success", False)
                })
                
                await asyncio.sleep(0.1)
                
            except Exception as e:
                logger.error(f"Error in experiment B step {i}: {e}")
                continue
        
        # Calculate slope
        hyper_energies = [r["hyper_energy"] for r in experiment_results]
        hyper_slope = self.calculate_slope(hyper_energies)
        
        # Store results
        self.experiment_history["B"] = {
            "results": experiment_results,
            "hyper_slope": hyper_slope,
            "success": hyper_slope > 0,  # Should be positive (complexity > precision)
            "timestamp": time.time()
        }
        
        logger.info(f"Experiment B complete. Hyper slope: {hyper_slope:.4f}, Success: {hyper_slope > 0}")
        return hyper_slope > 0
    
    async def experiment_C_entropy(self):
        """Lock roles to collapse entropy, then release; watch entropy/pair spikes drop."""
        logger.info("Running Experiment C: Entropy Validation")
        
        experiment_results = []
        
        # Phase 1: Lock roles (low entropy)
        logger.info("Phase 1: Locking agent roles (low entropy)")
        await self.lock_agent_roles()
        
        for i in range(20):
            task = {"type": "standard_task", "description": f"Locked role task {i}"}
            try:
                await self.organism.execute_task_on_random_organ(task)
                experiment_results.append({
                    "experiment": "C",
                    "phase": "locked",
                    "step": i,
                    "entropy": self.ledger.entropy,
                    "pair_energy": self.ledger.pair,
                    "total_energy": self.ledger.total
                })
                await asyncio.sleep(0.1)
            except Exception as e:
                logger.error(f"Error in experiment C locked phase step {i}: {e}")
                continue
        
        # Phase 2: Release roles (high entropy)
        logger.info("Phase 2: Releasing agent roles (high entropy)")
        await self.release_agent_roles()
        
        for i in range(20):
            task = {"type": "standard_task", "description": f"Released role task {i}"}
            try:
                await self.organism.execute_task_on_random_organ(task)
                experiment_results.append({
                    "experiment": "C",
                    "phase": "released",
                    "step": i,
                    "entropy": self.ledger.entropy,
                    "pair_energy": self.ledger.pair,
                    "total_energy": self.ledger.total
                })
                await asyncio.sleep(0.1)
            except Exception as e:
                logger.error(f"Error in experiment C released phase step {i}: {e}")
                continue
        
        # Calculate entropy change
        locked_results = [r for r in experiment_results if r["phase"] == "locked"]
        released_results = [r for r in experiment_results if r["phase"] == "released"]
        
        if locked_results and released_results:
            locked_entropy = np.mean([r["entropy"] for r in locked_results])
            released_entropy = np.mean([r["entropy"] for r in released_results])
            entropy_change = released_entropy - locked_entropy
            
            # Store results
            self.experiment_history["C"] = {
                "results": experiment_results,
                "locked_entropy": locked_entropy,
                "released_entropy": released_entropy,
                "entropy_change": entropy_change,
                "success": released_entropy > locked_entropy,
                "timestamp": time.time()
            }
            
            logger.info(f"Experiment C complete. Entropy change: {entropy_change:.4f}, Success: {released_entropy > locked_entropy}")
            return released_entropy > locked_entropy
        else:
            logger.error("Experiment C failed: insufficient data")
            return False
    
    async def experiment_D_memory(self):
        """Sweep VQ-VAE compression threshold; plot mem-term vs staleness."""
        logger.info("Running Experiment D: Memory Validation")
        
        compression_thresholds = [0.1, 0.3, 0.5, 0.7, 0.9]
        experiment_results = []
        
        for threshold in compression_thresholds:
            logger.info(f"Testing compression threshold: {threshold}")
            
            # Set compression threshold
            await self.set_memory_compression_threshold(threshold)
            
            # Run tasks and measure memory energy
            for i in range(10):
                task = {"type": "memory_intensive_task", "description": f"Memory task {i} at threshold {threshold}"}
                try:
                    await self.organism.execute_task_on_random_organ(task)
                    experiment_results.append({
                        "experiment": "D",
                        "threshold": threshold,
                        "step": i,
                        "mem_energy": self.ledger.mem,
                        "staleness": self.get_memory_staleness(),
                        "compression_ratio": threshold
                    })
                    await asyncio.sleep(0.1)
                except Exception as e:
                    logger.error(f"Error in experiment D step {i} at threshold {threshold}: {e}")
                    continue
        
        # Calculate memory efficiency metrics
        memory_efficiency = self.calculate_memory_efficiency(experiment_results)
        
        # Store results
        self.experiment_history["D"] = {
            "results": experiment_results,
            "memory_efficiency": memory_efficiency,
            "success": memory_efficiency > 0.5,  # Should have >50% efficiency
            "timestamp": time.time()
        }
        
        logger.info(f"Experiment D complete. Memory efficiency: {memory_efficiency:.4f}")
        return memory_efficiency > 0.5
    
    async def lock_agent_roles(self):
        """Lock agent roles to reduce entropy."""
        logger.info("Locking agent roles to reduce entropy")
        # This would be implemented to force agents into specific roles
        # For now, we'll simulate this by adjusting the energy calculation
        pass
    
    async def release_agent_roles(self):
        """Release agent roles to increase entropy."""
        logger.info("Releasing agent roles to increase entropy")
        # This would be implemented to allow agents to switch roles freely
        # For now, we'll simulate this by adjusting the energy calculation
        pass
    
    async def set_memory_compression_threshold(self, threshold: float):
        """Set memory compression threshold."""
        logger.info(f"Setting memory compression threshold to {threshold}")
        # This would be implemented to adjust memory system compression
        # For now, we'll simulate this
        pass
    
    def get_memory_staleness(self) -> float:
        """Get current memory staleness metric."""
        # This would be implemented to get actual memory staleness
        # For now, return a simulated value
        return np.random.uniform(0.1, 0.9)
    
    def calculate_memory_efficiency(self, results: List[Dict[str, Any]]) -> float:
        """Calculate memory efficiency from experiment results."""
        if not results:
            return 0.0
        
        # Calculate correlation between compression and memory energy
        thresholds = [r["compression_ratio"] for r in results]
        mem_energies = [r["mem_energy"] for r in results]
        
        if len(thresholds) < 2:
            return 0.0
        
        try:
            correlation = np.corrcoef(thresholds, mem_energies)[0, 1]
            return abs(correlation) if not np.isnan(correlation) else 0.0
        except:
            return 0.0
    
    def calculate_slope(self, values: List[float], window: int = 10) -> float:
        """Calculate slope of recent values using linear regression."""
        if len(values) < window:
            return 0.0
        
        recent_values = values[-window:]
        x = np.arange(len(recent_values))
        
        if len(recent_values) < 2:
            return 0.0
        
        try:
            slope, _ = np.polyfit(x, recent_values, 1)
            return float(slope)
        except (ValueError, np.linalg.LinAlgError):
            return 0.0
    
    def get_experiment_summary(self) -> Dict[str, Any]:
        """Get summary of all experiments."""
        summary = {
            "total_experiments": len(self.experiment_history),
            "successful_experiments": sum(1 for exp in self.experiment_history.values() if exp.get("success", False)),
            "experiments": {}
        }
        
        for exp_name, exp_data in self.experiment_history.items():
            summary["experiments"][exp_name] = {
                "success": exp_data.get("success", False),
                "timestamp": exp_data.get("timestamp", 0),
                "key_metrics": self.extract_key_metrics(exp_name, exp_data)
            }
        
        return summary
    
    def extract_key_metrics(self, exp_name: str, exp_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract key metrics for an experiment."""
        if exp_name == "A":
            return {"pair_slope": exp_data.get("pair_slope", 0)}
        elif exp_name == "B":
            return {"hyper_slope": exp_data.get("hyper_slope", 0)}
        elif exp_name == "C":
            return {
                "entropy_change": exp_data.get("entropy_change", 0),
                "locked_entropy": exp_data.get("locked_entropy", 0),
                "released_entropy": exp_data.get("released_entropy", 0)
            }
        elif exp_name == "D":
            return {"memory_efficiency": exp_data.get("memory_efficiency", 0)}
        else:
            return {}

# Legacy functions for backward compatibility
def run_experiment_A_pair(): 
    """Legacy function for backward compatibility."""
    logger.warning("run_experiment_A_pair() is deprecated. Use EnergyValidationHarness.experiment_A_pair() instead.")
    return None

def run_experiment_B_hyper(): 
    """Legacy function for backward compatibility."""
    logger.warning("run_experiment_B_hyper() is deprecated. Use EnergyValidationHarness.experiment_B_hyper() instead.")
    return None
