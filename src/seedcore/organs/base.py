# Copyright 2024 SeedCore Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is auto-generated by create_seedcore_skeleton.py
"""
Base Organ abstraction.
Each Organ hosts a local coordinator (Fast Loop) that selects agents and reports metrics
upstream to the energy system. See Â§4, Â§6, and Â§3.x gradient proxies.
"""

from __future__ import annotations
import asyncio
import contextlib
import os
import socket
import uuid
import random
import signal
import logging
from typing import List, Any, TYPE_CHECKING, Dict, Optional, Union

import ray

from seedcore.models import TaskPayload
from ..agents.roles import (
    RoleRegistry,
    DEFAULT_ROLE_REGISTRY,
    SkillStoreProtocol,
    NullSkillStore,
)

if TYPE_CHECKING:
    from ..agents.ray_agent import RayAgent

logger = logging.getLogger(__name__)

# Configurable heartbeat parameters
HB_BASE = float(os.getenv("RUNTIME_HB_BASE_S", "3.0"))     # 3s
HB_JITTER = float(os.getenv("RUNTIME_HB_JITTER_S", "2.0")) # +[0..2]s
HB_BACKOFF_MAX = float(os.getenv("RUNTIME_HB_BACKOFF_S", "10.0"))

@ray.remote
class Organ:
    """
    Stateful Ray-based organ actor for COA framework.
    
    Each organ acts as a specialized container for pools of agents,
    reflecting the "swarm-of-swarms" model central to the COA framework.
    """
    
    def __init__(
        self,
        organ_id: str,
        organ_type: str,
        serve_route: Optional[str] = None,
        *,
        role_registry: Optional[RoleRegistry] = None,
        skill_store: Optional[SkillStoreProtocol] = None,
    ):
        self.organ_id = organ_id
        self.organ_type = organ_type
        self.serve_route = serve_route
        self.agents: Dict[str, 'RayAgent'] = {}

        # Role/skill context shared with registered agents (if applicable)
        self.role_registry: RoleRegistry = role_registry or DEFAULT_ROLE_REGISTRY
        self.skill_store: SkillStoreProtocol = skill_store or NullSkillStore()

        # Runtime registry fields
        self.instance_id = uuid.uuid4().hex
        self._repo = None
        self._hb_task: Optional[asyncio.Task] = None
        self._started = False
        self._closing = asyncio.Event()
        
        # Database session factory
        try:
            from seedcore.database import get_async_pg_session_factory
            self._session_factory = get_async_pg_session_factory()
        except Exception as exc:
            logger.warning(f"Failed to initialize database session factory: {exc}")
            self._session_factory = None

    # ------------------------------------------------------------------
    # Runtime registry helpers
    # ------------------------------------------------------------------
    async def _repo_lazy(self):
        if self._repo is None:
            from ..graph.agent_repository import AgentGraphRepository
            self._repo = AgentGraphRepository()
        return self._repo

    async def start(self) -> Dict[str, Any]:
        """Register in runtime registry and start heartbeats after readiness."""
        if self._started:
            return {"status": "alive", "instance_id": self.instance_id, "logical_id": self.organ_id}
        
        repo = await self._repo_lazy()
        
        if not self._session_factory:
            logger.warning("No database session factory available, skipping registry registration")
            self._started = True
            return {"status": "alive", "instance_id": self.instance_id, "logical_id": self.organ_id}

        # Register in 'starting' status
        async with self._session_factory() as session:
            async with session.begin():
                cluster_epoch = await repo.get_current_cluster_epoch(session)
                await repo.register_instance(
                    session=session,
                    instance_id=self.instance_id,
                    logical_id=self.organ_id,
                    cluster_epoch=cluster_epoch,
                    actor_name=self.organ_id,
                    serve_route=self.serve_route,
                    node_id=os.getenv("RAY_NODE_ID") or "",
                    ip_address=socket.gethostbyname(socket.gethostname()),
                    pid=os.getpid(),
                )
                logger.info(f"âœ… Organ instance {self.instance_id} (logical: {self.organ_id}) registered for epoch {cluster_epoch}")

        # Probe dependencies / Serve readiness here if applicable
        # await self._probe_ready()

        # Mark alive after readiness
        async with self._session_factory() as session:
            async with session.begin():
                await repo.set_instance_status(session, self.instance_id, "alive")
        logger.info(f"âœ… Organ instance {self.instance_id} (logical: {self.organ_id}) marked alive")

        # Heartbeat with jitter+backoff
        self._hb_task = asyncio.create_task(self._heartbeat_loop())
        
        # Try to handle SIGTERM to mark dead early
        try:
            loop = asyncio.get_running_loop()
            loop.add_signal_handler(signal.SIGTERM, lambda: asyncio.create_task(self.close()))
        except Exception:
            pass  # Signal handling not available in all contexts
        
        self._started = True
        return {"status": "alive", "instance_id": self.instance_id, "logical_id": self.organ_id}

    async def _heartbeat_loop(self):
        repo = await self._repo_lazy()
        backoff = 0.5
        while not self._closing.is_set():
            try:
                if self._session_factory:
                    async with self._session_factory() as session:
                        async with session.begin():
                            await repo.beat(session, self.instance_id)
                backoff = 0.5  # reset on success
            except Exception as e:
                # transient DB hiccupâ€”bounded backoff
                logger.warning(f"âŒ Organ heartbeat for {self.organ_id} failed: {e}, backing off {backoff}s")
                await asyncio.sleep(backoff)
                backoff = min(backoff * 2, HB_BACKOFF_MAX)
            
            # jittered sleep
            try:
                await asyncio.wait_for(self._closing.wait(), timeout=HB_BASE + random.random() * HB_JITTER)
            except asyncio.TimeoutError:
                pass  # normal path: timeout from wait_for -> loop again

    async def close(self) -> Dict[str, Any]:
        """Stop heartbeats and mark dead in runtime registry."""
        if self._closing.is_set():
            return {"status": "dead", "instance_id": self.instance_id}
        
        logger.info(f"ðŸ›‘ Organ instance {self.instance_id} (logical: {self.organ_id}) closing...")
        self._closing.set()
        
        if self._hb_task:
            self._hb_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._hb_task
        
        repo = await self._repo_lazy()
        with contextlib.suppress(Exception):
            if self._session_factory:
                async with self._session_factory() as session:
                    async with session.begin():
                        await repo.set_instance_status(session, self.instance_id, "dead")
        
        logger.info(f"âœ… Organ instance {self.instance_id} (logical: {self.organ_id}) marked dead.")
        return {"status": "dead", "instance_id": self.instance_id}

    def register_agent(self, agent_id: str, agent_handle: 'RayAgent'):
        """Registers a Ray agent actor with this organ."""
        self.agents[agent_id] = agent_handle

    def get_agent_count(self) -> int:
        """Returns the number of agents in this organ."""
        return len(self.agents)

    def _prepare_task_dict(self, task: Union[TaskPayload, Dict[str, Any]]) -> Dict[str, Any]:
        """Normalize incoming task payloads and preserve any extra fields."""
        extra_fields: Dict[str, Any] = {}

        if isinstance(task, TaskPayload):
            payload = task
            task_dict = payload.model_dump()
        elif isinstance(task, dict):
            raw_task = dict(task)
            try:
                payload = TaskPayload.from_db(raw_task)
            except Exception as exc:
                logger.debug(
                    "Organ %s: TaskPayload.from_db fallback due to %s; building direct payload",
                    self.organ_id,
                    exc,
                )
                fallback_id = raw_task.get("task_id") or raw_task.get("id") or uuid.uuid4().hex
                payload = TaskPayload(
                    task_id=str(fallback_id),
                    type=raw_task.get("type") or "unknown_task",
                    params=raw_task.get("params") or {},
                    description=raw_task.get("description") or "",
                    domain=raw_task.get("domain"),
                    drift_score=float(raw_task.get("drift_score") or 0.0),
                )
            task_dict = payload.model_dump()
            extra_fields = {k: v for k, v in raw_task.items() if k not in task_dict}
        else:
            raise TypeError(f"Unsupported task payload type: {type(task)}")

        task_id = payload.task_id or uuid.uuid4().hex
        if not payload.task_id or payload.task_id in ("", "None"):
            payload = payload.copy(update={"task_id": task_id})
            task_dict = payload.model_dump()

        for key, value in extra_fields.items():
            if key not in task_dict:
                task_dict[key] = value

        task_dict.setdefault("id", task_id)
        task_dict.setdefault("task_id", task_id)
        return task_dict

    def select_agent(self, task: Union[TaskPayload, Dict[str, Any]]) -> 'RayAgent':
        """
        Selects an agent within the organ for a task.
        TODO: Implement the full energy-aware scoring proxy here.
        """
        if not self.agents:
            raise ValueError("No agents available in this organ.")
        # Simple random selection for now
        import random
        agent_id = random.choice(list(self.agents.keys()))
        return self.agents[agent_id]

    async def run_task(self, task: Union[TaskPayload, Dict[str, Any]]):
        """Selects an agent and executes a task, returning the result."""
        task_dict = self._prepare_task_dict(task)
        agent = self.select_agent(task_dict)
        # Use .remote() to call the Ray actor method
        result_ref = agent.execute_task.remote(task_dict)
        return await result_ref

    def get_status(self) -> Dict[str, Any]:
        """Returns the current status of the organ."""
        return {
            "organ_id": self.organ_id,
            "organ_type": self.organ_type,
            "instance_id": str(self.instance_id),
            "agent_count": len(self.agents),
            "agent_ids": list(self.agents.keys()),
            "status": "healthy"  # Explicit status field for health checks
        }

    def get_agent_handles(self) -> Dict[str, 'RayAgent']:
        """Returns all agent handles in this organ."""
        return self.agents.copy()

    def remove_agent(self, agent_id: str) -> bool:
        """Removes an agent from this organ."""
        if agent_id in self.agents:
            del self.agents[agent_id]
            return True
        return False
    
    def ping(self) -> str:
        """Health check method to verify the organ is responsive."""
        return "pong"
