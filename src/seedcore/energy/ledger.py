# Copyright 2024 SeedCore Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is auto-generated by create_seedcore_skeleton.py
"""
Energy ledger and incremental accounting.
Implements the rolling per-term energy ledger described in Enhanced-cognitive-core-energy-validation
§3.x.2–3.x.3. See also /energy/gradient telemetry schema.
Key Terms:
    pair, hyper, entropy, reg, mem
    total() returns scalar E
"""

from dataclasses import dataclass, field
from collections import deque
from typing import Dict, Any, Optional
import time, uuid

# New: persistence (append-only ledger + balances)
from .energy_persistence import EnergyLedgerStore, EnergyTx

@dataclass
class EnergyLedger:
    pair: float = 0.0
    hyper: float = 0.0
    entropy: float = 0.0
    reg: float = 0.0
    mem: float = 0.0
    
    # Energy history tracking
    pair_history: deque = field(default_factory=lambda: deque(maxlen=1000))
    hyper_history: deque = field(default_factory=lambda: deque(maxlen=1000))
    entropy_history: deque = field(default_factory=lambda: deque(maxlen=1000))
    reg_history: deque = field(default_factory=lambda: deque(maxlen=1000))
    mem_history: deque = field(default_factory=lambda: deque(maxlen=1000))
    total_history: deque = field(default_factory=lambda: deque(maxlen=1000))
    
    # Last delta tracking
    last_delta: float = 0.0
    
    # Weight parameters for adaptive control
    alpha: float = 0.5
    lambda_reg: float = 0.01
    beta_mem: float = 0.2

    def __post_init__(self):
        # Lazy default: use MySQL-backed CheckpointStore unless overridden by env/config
        self._ledger_store: Optional[EnergyLedgerStore] = None

    def _store(self) -> EnergyLedgerStore:
        if self._ledger_store is None:
            # Default to environment-configured backend; enable by default
            cfg = {"enabled": True}
            self._ledger_store = EnergyLedgerStore(cfg)
        return self._ledger_store

    def log_step(self, breakdown: Dict[str, float], extra: Dict[str, Any]) -> Dict[str, Any]:
        """Record a step with breakdown, persist tx, and update balances."""
        ts_val = float(extra.get("ts", time.time()))
        dE_val = float(extra.get("dE", 0.0))
        rec = {
            "ts": int(ts_val),
            "dE": dE_val,
            "terms": {
                "pair": float(breakdown.get("pair", 0.0)),
                "hyper": float(breakdown.get("hyper", 0.0)),
                "entropy": float(breakdown.get("entropy", 0.0)),
                "reg": float(breakdown.get("reg", 0.0)),
                "mem": float(breakdown.get("mem", 0.0)),
                "total": float(breakdown.get("total", 0.0)),
            },
            "p_fast": float(extra.get("p_fast", 0.0)),
            "ocps_drift": float(extra.get("drift", 0.0)),
            "beta_mem": float(extra.get("beta_mem", self.beta_mem)),
        }
        # Update internal state
        self.pair = rec["terms"]["pair"]
        self.hyper = rec["terms"]["hyper"]
        self.entropy = rec["terms"]["entropy"]
        self.reg = rec["terms"]["reg"]
        self.mem = rec["terms"]["mem"]
        self.last_delta = rec["dE"]
        self.total_history.append(rec["terms"]["total"])

        # Persist transaction via EnergyLedgerStore (cluster scope by default)
        try:
            tx = EnergyTx(
                tx_id=str(uuid.uuid4()),
                ts=ts_val,
                scope=str(extra.get("scope", "cluster")),
                scope_id=str(extra.get("scope_id", "-")),
                step_id=extra.get("step_id"),
                dE=float(breakdown.get("total", 0.0)),
                cost=float(extra.get("cost", 0.0)),
                breakdown={k: float(v) for k, v in rec["terms"].items()},
                meta={
                    "p_fast": rec["p_fast"],
                    "drift": rec["ocps_drift"],
                },
            )
            ok = self._store().append_tx(tx)
            bal_after = self._store().apply_tx_to_balance(tx) if ok else None
            rec.update({"tx_id": tx.tx_id, "ok": ok, "balance_after": bal_after})
        except Exception:
            # Persistence failures should not crash control loop
            rec.update({"ok": False})
        return rec

    @property
    def total(self) -> float:
        return self.pair + self.hyper + self.entropy + self.reg + self.mem

    def reset(self):
        self.pair = self.hyper = self.entropy = self.reg = self.mem = 0.0
        self.last_delta = 0.0
        
        # Clear history
        self.pair_history.clear()
        self.hyper_history.clear()
        self.entropy_history.clear()
        self.reg_history.clear()
        self.mem_history.clear()
        self.total_history.clear()
    
    def update_term(self, term: str, delta: float):
        """Update energy term with history tracking."""
        current_value = getattr(self, term)
        new_value = current_value + delta
        setattr(self, term, new_value)
        
        # Update history
        history_attr = f"{term}_history"
        if hasattr(self, history_attr):
            getattr(self, history_attr).append(new_value)
        
        # Update total history
        self.total_history.append(self.total)
        
        # Track last delta
        self.last_delta = delta
        
        print(f"Updated {term} energy by {delta:.4f}. New total: {new_value:.4f}")
    
    def get_recent_energy(self, window: int = 100) -> Dict[str, list]:
        """Get recent energy values for all terms."""
        return {
            "pair": list(self.pair_history)[-window:] if len(self.pair_history) >= window else list(self.pair_history),
            "hyper": list(self.hyper_history)[-window:] if len(self.hyper_history) >= window else list(self.hyper_history),
            "entropy": list(self.entropy_history)[-window:] if len(self.entropy_history) >= window else list(self.entropy_history),
            "reg": list(self.reg_history)[-window:] if len(self.reg_history) >= window else list(self.reg_history),
            "mem": list(self.mem_history)[-window:] if len(self.mem_history) >= window else list(self.mem_history),
            "total": list(self.total_history)[-window:] if len(self.total_history) >= window else list(self.total_history)
        }
    
    def add_pair_delta(self, delta: float) -> None:
        """Adds a pre-calculated delta to the pair energy term."""
        self.update_term("pair", delta)
    
    def add_hyper_delta(self, complexity: float, precision: float) -> None:
        """Increment hyper term based on complexity-precision tradeoff."""
        # Hyper energy increases with complexity, decreases with precision
        delta = complexity - precision
        self.update_term("hyper", delta)
    
    def add_entropy_delta(self, choice_count: int, uncertainty: float) -> None:
        """Increment entropy term based on choice availability and uncertainty."""
        # Entropy increases when there are many choices and high uncertainty
        delta = choice_count * uncertainty * 0.1  # Scale factor to keep reasonable
        self.update_term("entropy", delta)
    
    def add_reg_delta(self, regularization_strength: float, model_complexity: float) -> None:
        """Increment regularization term based on model complexity control."""
        # Regularization energy increases with model complexity and regularization strength
        delta = regularization_strength * model_complexity
        self.update_term("reg", delta)
    
    def add_mem_delta(self, memory_usage: float, compression_ratio: float) -> None:
        """Increment memory term based on memory usage and compression."""
        # Memory energy increases with usage, decreases with compression
        delta = memory_usage - compression_ratio
        self.update_term("mem", delta)

