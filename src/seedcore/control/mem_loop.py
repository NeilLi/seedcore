# Copyright 2024 SeedCore Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is auto-generated by create_seedcore_skeleton.py
"""
Adaptive Memory Loop: compression control via dE/dCostVQ (Section 6, 3.x.4 & 7).
"""

from typing import List
from ..organs.base import Organ
from ..ops.energy.api import _ledger
from ..ops.energy.grad_adapter import get_global_gradient_bus

def adaptive_mem_update(organs: List[Organ], compression_knob: float = 0.5):
    """
    Sweep compression knob, estimate slope dE/dCostVQ for adaptive memory control.
    This function adjusts memory utilization and compression based on energy gradients.
    """
    try:
        # Prefer gradient-driven memory control
        from ..organs.organism_manager import organism_manager
        import asyncio
        us = None
        try:
            if organism_manager is not None:
                us = asyncio.run(organism_manager.get_unified_state())
        except Exception:
            us = None
        bus = get_global_gradient_bus()
        grads = bus.latest(us if us is not None else {"agents": {}}, allow_stale=True)
        dE_dm = float(getattr(grads, 'dE_dmem', 0.0))
        # Simple proportional control on compression knob based on slope sign
        k = 0.05
        compression_knob = float(max(0.0, min(1.0, compression_knob - k * dE_dm)))
        print(f"Gradient-driven compression -> knob={compression_knob:.2f} (dE/dmem={dE_dm:.3f})")
    except Exception:
        # Fallback: legacy heuristic based on ledger ratios
        current_mem_energy = _ledger.mem
        current_total_energy = _ledger.total
        mem_efficiency = abs(current_mem_energy) / (1.0 + abs(current_total_energy))
        if mem_efficiency > 0.3:
            compression_knob = min(1.0, compression_knob + 0.1)
            print(f"High memory energy detected. Increasing compression to {compression_knob:.2f}")
        elif mem_efficiency < 0.1:
            compression_knob = max(0.0, compression_knob - 0.1)
            print(f"Low memory energy detected. Decreasing compression to {compression_knob:.2f}")
    
    # Update agent memory utilization based on compression
    for organ in organs:
        for agent in organ.agents.values():
            # Adjust memory utilization inversely to compression
            # Higher compression = lower memory utilization needed
            target_mem_util = 1.0 - compression_knob
            
            # Smooth transition to target memory utilization
            current_mem_util = agent.mem_util
            mem_util_delta = (target_mem_util - current_mem_util) * 0.1
            agent.mem_util = max(0.0, min(1.0, current_mem_util + mem_util_delta))
            
            # Update memory energy based on new utilization and compression
            _ledger.add_mem_delta(agent.mem_util, compression_knob)
    
    return compression_knob

def estimate_memory_gradient(organs: List[Organ], compression_step: float = 0.1) -> float:
    """
    Estimate the gradient dE/dCostVQ by perturbing compression and measuring energy change.
    """
    # Store current state
    original_mem_energy = _ledger.mem
    original_compression = 0.5  # Assume baseline compression
    
    # Perturb compression upward
    test_compression = original_compression + compression_step
    
    # Simulate energy change with new compression
    # This is a simplified model - in practice you'd need more sophisticated estimation
    energy_change = 0.0
    for organ in organs:
        for agent in organ.agents.values():
            # Estimate energy change based on compression change
            mem_util_change = (1.0 - test_compression) - (1.0 - original_compression)
            energy_change += mem_util_change * agent.capability * 0.1
    
    # Calculate gradient (energy change per compression change)
    gradient = energy_change / compression_step if compression_step != 0 else 0.0
    
    print(f"Memory gradient estimate: dE/dCostVQ â‰ˆ {gradient:.3f}")
    return gradient

def get_memory_metrics(organs: List[Organ]) -> dict:
    """
    Get current memory utilization metrics across all agents.
    """
    total_mem_util = 0.0
    agent_count = 0
    
    for organ in organs:
        for agent in organ.agents.values():
            total_mem_util += agent.mem_util
            agent_count += 1
    
    avg_mem_util = total_mem_util / agent_count if agent_count > 0 else 0.0
    
    return {
        "average_memory_utilization": avg_mem_util,
        "total_agents": agent_count,
        "current_memory_energy": _ledger.mem,
        "memory_efficiency": abs(_ledger.mem) / (1.0 + abs(_ledger.total))
    }
