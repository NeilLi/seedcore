# This file is auto-generated by create_seedcore_skeleton.py
"""
Adaptive Memory Loop: compression control via dE/dCostVQ (Section 6, 3.x.4 & 7).
"""

from typing import List
from ..organs.base import Organ
from ..energy.api import _ledger

def adaptive_mem_update(organs: List[Organ], compression_knob: float = 0.5):
    """
    Sweep compression knob, estimate slope dE/dCostVQ for adaptive memory control.
    This function adjusts memory utilization and compression based on energy gradients.
    """
    # Calculate current memory energy gradient
    current_mem_energy = _ledger.mem
    current_total_energy = _ledger.total
    
    # Estimate memory efficiency (lower is better)
    mem_efficiency = abs(current_mem_energy) / (1.0 + abs(current_total_energy))
    
    # Adjust compression based on memory efficiency
    if mem_efficiency > 0.3:  # High memory energy - increase compression
        compression_knob = min(1.0, compression_knob + 0.1)
        print(f"High memory energy detected. Increasing compression to {compression_knob:.2f}")
    elif mem_efficiency < 0.1:  # Low memory energy - decrease compression
        compression_knob = max(0.0, compression_knob - 0.1)
        print(f"Low memory energy detected. Decreasing compression to {compression_knob:.2f}")
    
    # Update agent memory utilization based on compression
    for organ in organs:
        for agent in organ.agents:
            # Adjust memory utilization inversely to compression
            # Higher compression = lower memory utilization needed
            target_mem_util = 1.0 - compression_knob
            
            # Smooth transition to target memory utilization
            current_mem_util = agent.mem_util
            mem_util_delta = (target_mem_util - current_mem_util) * 0.1
            agent.mem_util = max(0.0, min(1.0, current_mem_util + mem_util_delta))
            
            # Update memory energy based on new utilization and compression
            _ledger.add_mem_delta(agent.mem_util, compression_knob)
    
    return compression_knob

def estimate_memory_gradient(organs: List[Organ], compression_step: float = 0.1) -> float:
    """
    Estimate the gradient dE/dCostVQ by perturbing compression and measuring energy change.
    """
    # Store current state
    original_mem_energy = _ledger.mem
    original_compression = 0.5  # Assume baseline compression
    
    # Perturb compression upward
    test_compression = original_compression + compression_step
    
    # Simulate energy change with new compression
    # This is a simplified model - in practice you'd need more sophisticated estimation
    energy_change = 0.0
    for organ in organs:
        for agent in organ.agents:
            # Estimate energy change based on compression change
            mem_util_change = (1.0 - test_compression) - (1.0 - original_compression)
            energy_change += mem_util_change * agent.capability * 0.1
    
    # Calculate gradient (energy change per compression change)
    gradient = energy_change / compression_step if compression_step != 0 else 0.0
    
    print(f"Memory gradient estimate: dE/dCostVQ â‰ˆ {gradient:.3f}")
    return gradient

def get_memory_metrics(organs: List[Organ]) -> dict:
    """
    Get current memory utilization metrics across all agents.
    """
    total_mem_util = 0.0
    agent_count = 0
    
    for organ in organs:
        for agent in organ.agents:
            total_mem_util += agent.mem_util
            agent_count += 1
    
    avg_mem_util = total_mem_util / agent_count if agent_count > 0 else 0.0
    
    return {
        "average_memory_utilization": avg_mem_util,
        "total_agents": agent_count,
        "current_memory_energy": _ledger.mem,
        "memory_efficiency": abs(_ledger.mem) / (1.0 + abs(_ledger.total))
    }
