#!/usr/bin/env python3
"""
create_seedcore_skeleton.py

Bootstrap the SeedCore (Minimal Viable Cognitive Core) project structure.
This version creates the main package inside a `src` directory.

Run from the *repository root* — the directory that already contains `docs/`.

Usage:
    python3 create_seedcore_skeleton.py [--force] [--pkg-name seedcore]

This script is *idempotent*: it will not overwrite existing files unless --force is given.
"""

import argparse
import os
from pathlib import Path
import textwrap

# -----------------------------
# Directory Layout Documentation
# -----------------------------

RECOMMENDED_LAYOUT = """
seedcore/
  .gitignore
  docs/                          # you already created
  examples/
    quickstart.py
  notebooks/
    exploration.ipynb            # empty placeholder
  pyproject.toml
  README.md
  requirements.txt
  scripts/
    run_demo.sh
  src/                           # Source root
    seedcore/                    # Your python package
      __init__.py
      agents/
        __init__.py
        base.py
        lifecycle.py
      config/
        __init__.py
        defaults.yaml
      control/
        __init__.py
        fast_loop.py
        mem_loop.py
        slow_loop.py
      energy/
        __init__.py
        api.py
        ledger.py
        weights.py
      evolution/
        __init__.py
        operators.py
        weights.py
      experiments/
        __init__.py
        harness.py
      memory/
        __init__.py
        cost_vq.py
        tiers.py
      organs/
        __init__.py
        base.py
        registry.py
      telemetry/
        __init__.py
        schema.py
        server.py
      utils/
        __init__.py
        log.py
  tests/
    test_energy.py
    test_lifecycle.py
"""

# -----------------------------
# Templates
# -----------------------------

README_TMPL = """# SeedCore

**SeedCore** is the Minimal Viable Cognitive Core implementation of the Cognitive Organism Architecture (COA).
It provides an *energy-governed*, *organ-aware*, *hierarchical-memory* substrate for agent swarms.

> For theory + design context see: `docs/Enhanced-cognitive-core-energy-validation.md` (or the latest COA docs).

## Key Ideas
- Unified Energy Function (pair, hyper, entropy, reg, mem).
- Three Control Loops: Fast (agent select), Slow (role PSO), Adaptive (memory compression).
- Lifecycle coupling via capability & memory utility.
- Live telemetry `/energy/gradient` endpoint for auditability.

## Quickstart
```bash
pip install -e .
python -m seedcore.examples.quickstart
```
"""
GITIGNORE_TMPL = """# Python
__pycache__/
*.pyc
*.pyo
*.pyd
*.egg-info/
.eggs/
.build/
dist/
build/

# Virtual env
.venv/
venv/
env/

# Jupyter
.ipynb_checkpoints/

# OS
.DS_Store

# Local config
local_*.yaml
"""
PYPROJECT_TMPL = """[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "{pkg_name}"
version = "0.1.0"
description = "Minimal Viable Cognitive Core (SeedCore) - unified energy substrate for COA organisms."
authors = [{{name = "Neil Li", email = "example@example.com"}}]
readme = "README.md"
requires-python = ">=3.9"
dependencies = [
    "ray>=2.10",
    "dgl>=2.1",
    "numpy",
    "pydantic>=2",
    "fastapi",
    "uvicorn",
    "grpcio",
    "protobuf",
    "pyyaml",
]

[project.optional-dependencies]
dev = ["pytest", "black", "ruff", "mypy", "ipykernel"]

[tool.setuptools.packages.find]
where = ["src"]
"""
REQS_TMPL = """ray>=2.10
dgl>=2.1
numpy
pydantic>=2
fastapi
uvicorn
grpcio
protobuf
pyyaml
"""
DEFAULTS_YAML_TMPL = """# SeedCore default configuration
seedcore:
  telemetry_port: 8088
  grpc_port: 50055
  organs:
    - cognitive
    - actuator
    - utility
  entropy_floor: 0.2
  weights:
    w_pair: 1.0
    w_hyper: 1.0
    alpha: 0.5
    lambda_reg: 0.01
    beta_mem: 0.2
"""
# --- Minimal module docstring templates ---
MOD_HDR = "# This file is auto-generated by create_seedcore_skeleton.py\n"
def _ds(doc: str) -> str:
    return MOD_HDR + '"""\n' + textwrap.dedent(doc).strip() + '\n"""\n\n'

ENERGY_LEDGER_PY = _ds("""
Energy ledger and incremental accounting.
Implements the rolling per-term energy ledger described in Enhanced-cognitive-core-energy-validation
§3.x.2–3.x.3. See also /energy/gradient telemetry schema.
Key Terms:
    pair, hyper, entropy, reg, mem
    total() returns scalar E
""") + """from dataclasses import dataclass

@dataclass
class EnergyLedger:
    pair: float = 0.0
    hyper: float = 0.0
    entropy: float = 0.0
    reg: float = 0.0
    mem: float = 0.0

    @property
    def total(self) -> float:
        return self.pair + self.hyper + self.entropy + self.reg + self.mem

    def reset(self):
        self.pair = self.hyper = self.entropy = self.reg = self.mem = 0.0
"""
ENERGY_API_PY = _ds("""
Energy API surface.
Expose a Python call read_energy() and a server-facing handler to serve /energy/gradient
(JSON payload defined in §3.x.6 and §8 metrics schema).
""") + """from .ledger import EnergyLedger
from typing import Dict, Any
import time

_ledger = EnergyLedger()

def read_energy() -> Dict[str, float]:
    return {
        "pair": _ledger.pair,
        "hyper": _ledger.hyper,
        "entropy": _ledger.entropy,
        "reg": _ledger.reg,
        "mem": _ledger.mem,
        "total": _ledger.total,
    }

def energy_gradient_payload(extra: Dict[str, Any] | None = None) -> Dict[str, Any]:
    payload = {
        "ts": int(time.time()),
        "E_terms": read_energy(),
        # placeholders
        "agent_grad_proxy": {},
        "mem_pressure": {},
    }
    if extra:
        payload.update(extra)
    return payload
"""
ENERGY_WEIGHTS_PY = _ds("""
Adaptive energy weight shaping (Section 19).
Functions:
    adapt_energy_weights() -> applies Δspec, Δacc, Δsmart, Δreason
    project_bounds() -> clamp to safe intervals
""") + """from typing import Dict

class EnergyWeights:
    def __init__(self, w_pair=1.0, w_hyper=1.0, alpha=0.5, lambda_reg=0.01, beta_mem=0.2):
        self.w_pair = w_pair
        self.w_hyper = w_hyper
        self.alpha = alpha
        self.lambda_reg = lambda_reg
        self.beta_mem = beta_mem

    def as_dict(self) -> Dict[str, float]:
        return dict(
            w_pair=self.w_pair,
            w_hyper=self.w_hyper,
            alpha=self.alpha,
            lambda_reg=self.lambda_reg,
            beta_mem=self.beta_mem,
        )

    def project_bounds(self):
        # TODO configurable bounds
        self.w_pair   = max(0.0, min(self.w_pair,   10.0))
        self.w_hyper  = max(0.0, min(self.w_hyper,  10.0))
        self.alpha    = max(0.0, min(self.alpha,     5.0))
        self.lambda_reg = max(0.0, min(self.lambda_reg, 1.0))
        self.beta_mem = max(0.0, min(self.beta_mem,  5.0))


def adapt_energy_weights(weights: EnergyWeights, dspec, dacc, dsmart, dreason,
                         gamma_spec=0.1, gamma_acc=0.1, gamma_smart=0.1, gamma_reason=0.1):
    weights.w_pair  *= (1 + gamma_spec*dspec + gamma_acc*dacc)
    weights.w_hyper *= (1 + gamma_reason*dreason)
    weights.alpha   *= (1 - gamma_spec*dspec + max(0.0, -dreason)*gamma_reason)
    weights.lambda_reg *= (1 + gamma_smart*max(0.0,0.0))  # placeholder
    weights.beta_mem   *= (1 + gamma_smart*max(0.0,0.0))  # placeholder
    weights.project_bounds()
"""
ORGAN_BASE_PY = _ds("""
Base Organ abstraction.
Each Organ hosts a local coordinator (Fast Loop) that selects agents and reports metrics
upstream to the energy system. See §4, §6, and §3.x gradient proxies.
""") + """from __future__ import annotations
from typing import List, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from ..agents.base import Agent

class Organ:
    def __init__(self, organ_id: str):
        self.organ_id = organ_id
        self.agents: List['Agent'] = []

    def register(self, agent: 'Agent'):
        self.agents.append(agent)

    def select_agent(self, task) -> 'Agent':
        # TODO: implement energy-aware scoring proxy
        if not self.agents:
            raise ValueError("No agents available in this organ.")
        return self.agents[0]

    def run_task(self, task):
        agent = self.select_agent(task)
        return agent.execute(task)
"""
ORGAN_REGISTRY_PY = _ds("""
Organ registry + lookup table used by the router (fast vs escalate).
""") + """from typing import Dict
from .base import Organ

class OrganRegistry:
    def __init__(self):
        self._organs: Dict[str, Organ] = {}

    def add(self, organ: Organ):
        self._organs[organ.organ_id] = organ

    def get(self, organ_id: str) -> Organ:
        return self._organs[organ_id]

    def all(self) -> list[Organ]:
        return list(self._organs.values())
"""
AGENT_BASE_PY = _ds("""
Base Agent abstraction.
Implements capability & memory utility fields (Section 2.1).
""") + """from dataclasses import dataclass, field
from typing import Dict, Any

@dataclass
class Agent:
    agent_id: str
    capability: float = 0.0
    mem_util: float = 0.0
    role_probs: Dict[str, float] = field(default_factory=lambda: {'E':0.9,'S':0.1,'O':0.0})

    def execute(self, task: Any) -> Dict[str, Any]:
        # placeholder
        return {'ok': True, 'result': None}
"""
AGENT_LIFECYCLE_PY = _ds("""
Lifecycle transitions (Scout <-> Employed <-> Specialist).
Threshold logic from §2.1; event emitters feed Energy updates.
""") + """from .base import Agent

PROMOTE_TAU_C = 0.7
PROMOTE_TAU_U = 0.5

def evaluate_lifecycle(agent: Agent):
    if agent.capability >= PROMOTE_TAU_C and agent.mem_util >= PROMOTE_TAU_U:
        # promote to Employed/Specialist
        pass
"""
MEM_TIERS_PY = _ds("""
Memory tiers Ma/Mw/Mlt/Mfb (Section 7).
Simple in-memory placeholders; integrate storage backends later.
""") + """class MemoryTier:
    def __init__(self, name: str):
        self.name = name
        self.store = {}

    def write(self, k, v):
        self.store[k] = v

    def read(self, k):
        return self.store.get(k)

Ma = MemoryTier('Ma')
Mw = MemoryTier('Mw')
Mlt = MemoryTier('Mlt')
Mfb = MemoryTier('Mfb')
"""
MEM_COST_VQ_PY = _ds("""
CostVQ estimator: proxy cost for compression vs fidelity trade (Section 7, 3.x.4).
""") + """def cost_vq(bytes_used: int, recon_loss: float, stale_s: float,
            w_b=1.0, w_r=1.0, w_s=0.5) -> float:
    return w_b*bytes_used + w_r*recon_loss + w_s*stale_s
"""
CONTROL_FAST_PY = _ds("""
Fast Loop (~200ms): energy-aware agent selection (Section 6, 3.x.4).
""") + """from ..organs.base import Organ

def fast_loop_select_agent(organ: Organ, task):
    return organ.select_agent(task)
"""
CONTROL_SLOW_PY = _ds("""
Slow Loop (~2s): role evolution / PSO (Section 6, 3.x.4).
""") + """def slow_loop_update_roles(organs):
    # TODO: PSO or hillclimb to adjust role distributions
    pass
"""
CONTROL_MEM_PY = _ds("""
Adaptive Memory Loop: compression control via dE/dCostVQ (Section 6, 3.x.4 & 7).
""") + """def adaptive_mem_update():
    # TODO: sweep compression knob, estimate slope
    pass
"""
EVOL_WEIGHTS_PY = _ds("""
Front-axis driven energy weight adaptation (Section 19).
""") + """from ..energy.weights import adapt_energy_weights, EnergyWeights
"""
EVOL_OPERATORS_PY = _ds("""
Evolution operators: specialize agents, split organs, inject scouts, memory promotion (Section 19.2).
""") + """def maybe_specialize_agents(): ...
def maybe_split_organs(): ...
def maybe_inject_scouts(): ...
def maybe_promote_memory(): ...
"""
TELE_SCHEMA_PY = _ds("""
Telemetry schema objects (Section 8 & 3.x.6).
""") + """ENERGY_PAYLOAD_FIELDS = ['pair','hyper','entropy','reg','mem','total']
"""
TELE_SERVER_PY = _ds("""
Simple FastAPI/uvicorn server that exposes /energy/gradient.
""") + """from fastapi import FastAPI
from ..energy.api import energy_gradient_payload

app = FastAPI()

@app.get('/energy/gradient')
def energy_gradient():
    return energy_gradient_payload()
"""
EXP_HARNESS_PY = _ds("""
Synthetic experiment harness (Section 11).
Use to drive pair/hyper/entropy/mem sweeps and validate energy behavior.
""") + """def run_experiment_A_pair(): ...
def run_experiment_B_hyper(): ...
"""
UTIL_LOG_PY = _ds("""
Logging helpers; can wrap structlog or standard logging.
""") + """import logging
log = logging.getLogger('seedcore')
"""
EXAMPLE_QUICKSTART_PY = """# Quickstart demo for SeedCore
from seedcore.energy.api import energy_gradient_payload

if __name__ == '__main__':
    print('SeedCore quickstart: current energy payload:')
    print(energy_gradient_payload())
"""
TEST_ENERGY_PY = """from seedcore.energy.ledger import EnergyLedger

def test_ledger_total():
    e = EnergyLedger(pair=1, hyper=2, entropy=-1, reg=0, mem=0.5)
    assert e.total == 2.5
"""
TEST_LIFECYCLE_PY = """from seedcore.agents.base import Agent
from seedcore.agents.lifecycle import evaluate_lifecycle

def test_lifecycle_call():
    a = Agent('a1', capability=0.8, mem_util=0.6)
    evaluate_lifecycle(a)  # should not raise
"""
RUN_DEMO_SH = """#!/usr/bin/env bash
set -e
echo "Running SeedCore demo..."
python -m seedcore.examples.quickstart
"""

# -----------------------------
# Helper functions
# -----------------------------
def write_file(path: Path, contents: str, force: bool):
    """Writes contents to path, creating parent dirs. Skips if exists and not --force."""
    if path.exists() and not force:
        print(f"  - Skipping {path} (exists)")
        return False
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(contents)
    print(f"  + Created {path}")
    return True

def ensure_pkg_tree(src_root: Path, pkg_name: str, force: bool):
    """Create the full package directory tree inside src_root."""
    pkg = src_root / pkg_name
    print(f"\nEnsuring package tree at: {pkg}")

    # Top-level package __init__
    write_file(pkg / "__init__.py", f'"""{pkg_name} package root."""\n', force)
    
    # Core component subdirectories
    dirs = [
        "config", "energy", "organs", "agents", "memory", 
        "control", "evolution", "telemetry", "experiments", "utils"
    ]
    for d in dirs:
        (pkg / d).mkdir(exist_ok=True)
        write_file(pkg / d / "__init__.py", f'"""{d.capitalize()} subpackage."""\n', force)

    # Individual module files
    files = {
        "config/defaults.yaml": DEFAULTS_YAML_TMPL,
        "energy/ledger.py": ENERGY_LEDGER_PY,
        "energy/api.py": ENERGY_API_PY,
        "energy/weights.py": ENERGY_WEIGHTS_PY,
        "organs/base.py": ORGAN_BASE_PY,
        "organs/registry.py": ORGAN_REGISTRY_PY,
        "agents/base.py": AGENT_BASE_PY,
        "agents/lifecycle.py": AGENT_LIFECYCLE_PY,
        "memory/tiers.py": MEM_TIERS_PY,
        "memory/cost_vq.py": MEM_COST_VQ_PY,
        "control/fast_loop.py": CONTROL_FAST_PY,
        "control/slow_loop.py": CONTROL_SLOW_PY,
        "control/mem_loop.py": CONTROL_MEM_PY,
        "evolution/weights.py": EVOL_WEIGHTS_PY,
        "evolution/operators.py": EVOL_OPERATORS_PY,
        "telemetry/schema.py": TELE_SCHEMA_PY,
        "telemetry/server.py": TELE_SERVER_PY,
        "experiments/harness.py": EXP_HARNESS_PY,
        "utils/log.py": UTIL_LOG_PY,
    }
    for rel_path, content in files.items():
        write_file(pkg / rel_path, content, force)
    
    return pkg

def ensure_top_files(root: Path, pkg_name: str, force: bool):
    """Create project-level files like pyproject.toml, tests, examples, etc."""
    print(f"\nEnsuring top-level files in: {root}")

    # Project config files
    write_file(root / ".gitignore", GITIGNORE_TMPL, force)
    write_file(root / "README.md", README_TMPL, force)
    write_file(root / "pyproject.toml", PYPROJECT_TMPL.format(pkg_name=pkg_name), force)
    write_file(root / "requirements.txt", REQS_TMPL, force)

    # Ancillary directories
    write_file(root / "tests" / "test_energy.py", TEST_ENERGY_PY, force)
    write_file(root / "tests" / "test_lifecycle.py", TEST_LIFECYCLE_PY, force)
    write_file(root / "examples" / "quickstart.py", EXAMPLE_QUICKSTART_PY, force)
    
    # Executable script
    script_path = root / "scripts" / "run_demo.sh"
    if write_file(script_path, RUN_DEMO_SH, force):
        os.chmod(script_path, 0o755)

    # Notebooks placeholder
    nb_dir = root / "notebooks"
    nb_dir.mkdir(exist_ok=True)
    nb_file = nb_dir / "exploration.ipynb"
    if not nb_file.exists():
        nb_file.write_text('{\n "cells": [],\n "metadata": {},\n "nbformat": 4,\n "nbformat_minor": 2\n}\n')
        print(f"  + Created {nb_file}")
    else:
        print(f"  - Skipping {nb_file} (exists)")

# -----------------------------
# Main Execution
# -----------------------------
def main():
    """Main function to parse arguments and create the project skeleton."""
    ap = argparse.ArgumentParser(
        description="Bootstrap the SeedCore project structure with a src/ layout.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    ap.add_argument("--force", action="store_true", help="Overwrite existing stub files")
    ap.add_argument("--pkg-name", default="seedcore", help="Top-level python package name")
    args = ap.parse_args()

    project_root = Path(__file__).resolve().parent
    src_dir = project_root / "src"

    print("--- Creating SeedCore Skeleton ---")
    print(f"Project Root: {project_root}")
    print(f"Package Name: {args.pkg_name}")
    print(f"Force overwrite: {args.force}")
    
    # Create the package inside src/
    pkg_path = ensure_pkg_tree(src_dir, args.pkg_name, args.force)
    
    # Create all other files in the project root
    ensure_top_files(project_root, args.pkg_name, args.force)

    print("\n--- Skeleton Creation Complete! ---")
    print(f"Project structure created under: {project_root}")
    print(f"Python package located in:   {pkg_path}")
    print("\nNext Steps:")
    print("1. Install dependencies: pip install -r requirements.txt")
    print("2. Install in editable mode: pip install -e .")
    print("3. Run the quickstart example: python -m seedcore.examples.quickstart")
    print("-" * 35)

if __name__ == "__main__":
    main()

