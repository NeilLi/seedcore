diff --git a/deploy/setup-api.sh b/deploy/setup-api.sh
index 158dde6..369fd0e 100755
--- a/deploy/setup-api.sh
+++ b/deploy/setup-api.sh
@@ -242,6 +242,8 @@ spec:
             - { name: DSP_LOG_TO_STDOUT, value: "true" }
             - { name: TMPDIR, value: "/tmp" }
             - { name: TEMP,  value: "/tmp" }
+            - { name: RAY_ADDRESS, value: "ray://seedcore-svc-head-svc:10001" }
+            - { name: SEEDCORE_NS, value: "seedcore-dev" }
 ${ENV_FROM_BLOCK}
           volumeMounts:
             - name: logs-volume
diff --git a/entrypoints/cognitive_entrypoint.py b/entrypoints/cognitive_entrypoint.py
index 9b26a17..50409e8 100644
--- a/entrypoints/cognitive_entrypoint.py
+++ b/entrypoints/cognitive_entrypoint.py
@@ -17,6 +17,7 @@ from typing import Dict, Any, Optional
 import ray
 from ray import serve
 from fastapi import FastAPI
+from seedcore.utils.ray_utils import ensure_ray_initialized
 from pydantic import BaseModel
 
 # Add the project root to Python path
@@ -198,8 +199,9 @@ def main():
     """Main entrypoint for the cognitive serve service."""
     print("üöÄ Starting deployment driver for Cognitive Service...")
     try:
-        if not ray.is_initialized():
-            ray.init(address=RAY_ADDR, namespace=RAY_NS)
+        if not ensure_ray_initialized(ray_address=RAY_ADDR, ray_namespace=RAY_NS):
+            print("‚ùå Failed to initialize Ray connection")
+            sys.exit(1)
 
         # The application is defined by binding the deployment class
         cognitive_app = CognitiveService.bind()
diff --git a/entrypoints/serve_entrypoint.py b/entrypoints/serve_entrypoint.py
index 7ac2a5c..73a96ac 100644
--- a/entrypoints/serve_entrypoint.py
+++ b/entrypoints/serve_entrypoint.py
@@ -16,6 +16,7 @@ import traceback
 import ray
 from ray import serve
 from fastapi import FastAPI, Request
+from seedcore.utils.ray_utils import ensure_ray_initialized
 
 # Add the app directory to Python path
 sys.path.insert(0, '/app')
@@ -161,7 +162,9 @@ def main():
     # Connect to Ray
     try:
         log(f"Connecting to Ray at {RAY_ADDR} (namespace={RAY_NS})")
-        ray.init(address=RAY_ADDR, namespace=RAY_NS, runtime_env=runtime_env)
+        if not ensure_ray_initialized(ray_address=RAY_ADDR, ray_namespace=RAY_NS):
+            err("Failed to connect to Ray")
+            sys.exit(1)
         log("‚úÖ Connected to Ray successfully")
     except Exception as e:
         err(f"Failed to connect to Ray: {e}")
diff --git a/scripts/test_bootstrap_fix.py b/scripts/test_bootstrap_fix.py
index 63a3dbb..1435f7f 100755
--- a/scripts/test_bootstrap_fix.py
+++ b/scripts/test_bootstrap_fix.py
@@ -1,229 +1,123 @@
 #!/usr/bin/env python3
 """
-Test script to verify that the bootstrap fix resolves the "Failed to look up actor 'mw'" error.
-
-This script tests that:
-1. Bootstrap actors can be created successfully
-2. The mw actor is available after bootstrap
-3. MwManager can be initialized without errors
+Test script to verify the bootstrap fix works correctly.
 """
 
-import sys
 import os
-import time
+import sys
 import logging
-from pathlib import Path
 
-# Add the src directory to the Python path
-project_root = Path(__file__).parent.parent
-src_path = project_root / "src"
-sys.path.insert(0, str(src_path))
+# Add the project root to Python path
+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))
 
-# Configure logging
-logging.basicConfig(
-    level=logging.INFO,
-    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
-)
+# Set up logging
+logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
 logger = logging.getLogger(__name__)
 
-def test_bootstrap_actors():
-    """Test that bootstrap_actors can create the required singleton actors."""
+def test_ray_connection():
+    """Test Ray connection using the centralized utility."""
+    print("üß™ Testing Ray connection...")
+    
     try:
-        print("üîç Testing bootstrap_actors...")
+        from seedcore.utils.ray_utils import ensure_ray_initialized
         
-        # Import bootstrap function
-        from seedcore.bootstrap import bootstrap_actors
-        print("‚úÖ bootstrap_actors imported successfully")
-        
-        # Call bootstrap to create actors
-        print("üöÄ Calling bootstrap_actors()...")
-        miss_tracker, shared_cache, mw_store = bootstrap_actors()
-        print("‚úÖ bootstrap_actors() completed successfully")
-        
-        # Verify actors were created
-        print(f"üìä Created actors:")
-        print(f"   - MissTracker: {miss_tracker}")
-        print(f"   - SharedCache: {shared_cache}")
-        print(f"   - MwStore: {mw_store}")
-        
-        return True
+        # Test connection
+        result = ensure_ray_initialized()
+        print(f"‚úÖ Ray connection result: {result}")
         
+        if result:
+            print("‚úÖ Ray connection successful!")
+            return True
+        else:
+            print("‚ùå Ray connection failed!")
+            return False
+            
     except Exception as e:
-        print(f"‚ùå Failed to test bootstrap_actors: {e}")
+        print(f"‚ùå Ray connection test failed: {e}")
         return False
 
-def test_mw_actor_availability():
-    """Test that the mw actor is available after bootstrap."""
+def test_bootstrap_actors():
+    """Test bootstrap actors functionality."""
+    print("\nüß™ Testing bootstrap actors...")
+    
     try:
-        print("\nüîç Testing mw actor availability...")
-        
-        import ray
-        
-        # Check if Ray is initialized
-        if not ray.is_initialized():
-            print("‚ö†Ô∏è Ray not initialized, initializing...")
-            ray.init(address="auto", namespace="seedcore-dev")
-        
-        # Try to get the mw actor
-        print("üîç Looking for 'mw' actor...")
-        mw_actor = ray.get_actor("mw", namespace="seedcore-dev")
-        print(f"‚úÖ Found mw actor: {mw_actor}")
+        from seedcore.bootstrap import bootstrap_actors
         
-        # Test basic functionality
-        print("üß™ Testing mw actor functionality...")
-        result = ray.get(mw_actor.ping.remote())
-        print(f"‚úÖ mw actor ping successful: {result}")
+        print("Calling bootstrap_actors()...")
+        result = bootstrap_actors()
+        print(f"‚úÖ Bootstrap result: {result}")
         
         return True
         
     except Exception as e:
-        print(f"‚ùå Failed to test mw actor availability: {e}")
+        print(f"‚ùå Bootstrap test failed: {e}")
+        import traceback
+        traceback.print_exc()
         return False
 
-def test_mw_manager_initialization():
-    """Test that MwManager can be initialized without errors."""
+def test_organism_manager():
+    """Test organism manager initialization."""
+    print("\nüß™ Testing organism manager...")
+    
     try:
-        print("\nüîç Testing MwManager initialization...")
-        
-        # Import MwManager
-        from seedcore.memory.working_memory import MwManager
-        print("‚úÖ MwManager imported successfully")
+        from seedcore.organs.organism_manager import organism_manager
         
-        # Create MwManager instance
-        print("üöÄ Creating MwManager instance...")
-        mw_manager = MwManager("test_organ")
-        print("‚úÖ MwManager created successfully")
+        print("‚úÖ Organism manager imported successfully")
+        print(f"Initialized: {organism_manager._initialized}")
         
-        # Verify it has the required attributes
-        if hasattr(mw_manager, 'mw_store') and mw_manager.mw_store:
-            print("‚úÖ MwManager has mw_store")
-        else:
-            print("‚ö†Ô∏è MwManager missing mw_store")
-            return False
-        
-        if hasattr(mw_manager, '_cache'):
-            print("‚úÖ MwManager has _cache")
-        else:
-            print("‚ö†Ô∏è MwManager missing _cache")
-            return False
-        
-        print("üéâ MwManager initialization test passed!")
         return True
         
     except Exception as e:
-        print(f"‚ùå Failed to test MwManager initialization: {e}")
+        print(f"‚ùå Organism manager test failed: {e}")
+        import traceback
+        traceback.print_exc()
         return False
 
-def test_ray_agent_memory_managers():
-    """Test that RayAgent can initialize memory managers without errors."""
+def test_force_reinit():
+    """Test force reinit functionality."""
+    print("\nüß™ Testing force reinit...")
+    
     try:
-        print("\nüîç Testing RayAgent memory manager initialization...")
-        
-        # Import RayAgent
-        from seedcore.agents.ray_actor import RayAgent
-        print("‚úÖ RayAgent imported successfully")
+        from seedcore.utils.ray_utils import ensure_ray_initialized
         
-        # Create a test agent
-        print("üöÄ Creating test RayAgent...")
-        test_agent_id = f"test_agent_{int(time.time())}"
-        agent = RayAgent(agent_id=test_agent_id, initial_role_probs={'E': 0.5, 'S': 0.3, 'O': 0.2})
-        print("‚úÖ Test RayAgent created successfully")
+        # Test force reinit
+        result = ensure_ray_initialized(force_reinit=True)
+        print(f"‚úÖ Force reinit result: {result}")
         
-        # Check memory manager status
-        if agent.mw_manager is not None:
-            print("‚úÖ Agent has mw_manager")
-        else:
-            print("‚ö†Ô∏è Agent missing mw_manager")
-        
-        if agent.mlt_manager is not None:
-            print("‚úÖ Agent has mlt_manager")
-        else:
-            print("‚ö†Ô∏è Agent missing mlt_manager")
-        
-        print("üéâ RayAgent memory manager test passed!")
         return True
         
     except Exception as e:
-        print(f"‚ùå Failed to test RayAgent memory managers: {e}")
+        print(f"‚ùå Force reinit test failed: {e}")
         return False
 
-def test_environment_configuration():
-    """Test that environment variables are properly configured."""
-    print("\nüîç Testing environment configuration...")
-    
-    # Check environment variables
-    env_vars = {
-        'SEEDCORE_NS': os.getenv('SEEDCORE_NS'),
-        'RAY_NAMESPACE': os.getenv('RAY_NAMESPACE'),
-        'RAY_ADDRESS': os.getenv('RAY_ADDRESS'),
-        'AUTO_CREATE': os.getenv('AUTO_CREATE'),
-        'MW_ACTOR_NAME': os.getenv('MW_ACTOR_NAME'),
-    }
-    
-    for var, value in env_vars.items():
-        if value:
-            print(f"‚úÖ {var}: {value}")
-        else:
-            print(f"‚ö†Ô∏è {var}: Not set")
-    
-    # Determine effective namespace
-    effective_namespace = env_vars['RAY_NAMESPACE'] or env_vars['SEEDCORE_NS'] or "seedcore-dev"
-    print(f"\nüéØ Effective namespace: {effective_namespace}")
-    
-    return True
-
 def main():
     """Run all tests."""
-    print("üß™ Testing Bootstrap Fix for 'mw' Actor Error")
-    print("=" * 60)
+    print("üöÄ Starting bootstrap fix tests...\n")
     
     tests = [
-        ("Environment Configuration", test_environment_configuration),
-        ("Bootstrap Actors", test_bootstrap_actors),
-        ("MW Actor Availability", test_mw_actor_availability),
-        ("MwManager Initialization", test_mw_manager_initialization),
-        ("RayAgent Memory Managers", test_ray_agent_memory_managers),
+        test_ray_connection,
+        test_bootstrap_actors,
+        test_organism_manager,
+        test_force_reinit,
     ]
     
-    results = []
-    for test_name, test_func in tests:
-        print(f"\n{'='*50}")
-        print(f"Running: {test_name}")
-        print(f"{'='*50}")
-        
+    passed = 0
+    total = len(tests)
+    
+    for test in tests:
         try:
-            result = test_func()
-            results.append((test_name, result))
-            if result:
-                print(f"‚úÖ {test_name}: PASSED")
-            else:
-                print(f"‚ùå {test_name}: FAILED")
+            if test():
+                passed += 1
         except Exception as e:
-            print(f"‚ùå {test_name}: ERROR - {e}")
-            results.append((test_name, False))
-    
-    # Summary
-    print(f"\n{'='*60}")
-    print("TEST SUMMARY")
-    print(f"{'='*60}")
-    
-    passed = sum(1 for _, result in results if result)
-    total = len(results)
-    
-    for test_name, result in results:
-        status = "‚úÖ PASSED" if result else "‚ùå FAILED"
-        print(f"{test_name}: {status}")
+            print(f"‚ùå Test {test.__name__} crashed: {e}")
     
-    print(f"\nOverall: {passed}/{total} tests passed")
+    print(f"\nüìä Test Results: {passed}/{total} tests passed")
     
     if passed == total:
         print("üéâ All tests passed! The bootstrap fix is working correctly.")
-        print("\n‚úÖ The 'Failed to look up actor mw' error should now be resolved.")
-        print("‚úÖ Agents should be able to initialize memory managers successfully.")
         return 0
     else:
-        print("üí• Some tests failed. Please review the issues above.")
-        print("\nüîß The bootstrap fix may need additional configuration.")
+        print("‚ö†Ô∏è Some tests failed. Check the output above for details.")
         return 1
 
 if __name__ == "__main__":
diff --git a/scripts/test_ray_connection_fix.py b/scripts/test_ray_connection_fix.py
index c6b92a9..e9c2b50 100755
--- a/scripts/test_ray_connection_fix.py
+++ b/scripts/test_ray_connection_fix.py
@@ -1,234 +1,130 @@
 #!/usr/bin/env python3
 """
-Test script to verify that the Ray connection fix resolves the connection timeout error.
-
-This script tests that:
-1. Environment variables are properly set
-2. Ray connection can be established using the correct address
-3. The connection uses the proper service names from the environment
+Test script to verify the Ray connection fix works correctly.
 """
 
-import sys
 import os
-import time
+import sys
 import logging
-from pathlib import Path
 
-# Add the src directory to the Python path
-project_root = Path(__file__).parent.parent
-src_path = project_root / "src"
-sys.path.insert(0, str(src_path))
+# Add the project root to Python path
+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))
 
-# Configure logging
-logging.basicConfig(
-    level=logging.INFO,
-    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
-)
+# Set up logging
+logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
 logger = logging.getLogger(__name__)
 
-def test_environment_variables():
-    """Test that environment variables are properly configured."""
-    print("üîç Testing environment variables...")
-    
-    env_vars = {
-        'RAY_HOST': os.getenv('RAY_HOST'),
-        'RAY_PORT': os.getenv('RAY_PORT'),
-        'RAY_NAMESPACE': os.getenv('RAY_NAMESPACE'),
-        'SEEDCORE_NS': os.getenv('SEEDCORE_NS'),
-        'RAY_ADDRESS': os.getenv('RAY_ADDRESS'),
-    }
+def test_ray_connection():
+    """Test Ray connection using the centralized utility."""
+    print("üß™ Testing Ray connection...")
     
-    for var, value in env_vars.items():
-        if value:
-            print(f"‚úÖ {var}: {value}")
+    try:
+        from seedcore.utils.ray_utils import ensure_ray_initialized
+        
+        # Test connection
+        result = ensure_ray_initialized()
+        print(f"‚úÖ Ray connection result: {result}")
+        
+        if result:
+            print("‚úÖ Ray connection successful!")
+            return True
         else:
-            print(f"‚ö†Ô∏è {var}: Not set")
-    
-    # Determine effective values
-    ray_host = env_vars['RAY_HOST'] or "seedcore-svc-head-svc"
-    ray_port = env_vars['RAY_PORT'] or "10001"
-    ray_namespace = env_vars['RAY_NAMESPACE'] or env_vars['SEEDCORE_NS'] or "seedcore-dev"
-    
-    print(f"\nüéØ Effective values:")
-    print(f"   Ray Host: {ray_host}")
-    print(f"   Ray Port: {ray_port}")
-    print(f"   Ray Namespace: {ray_namespace}")
-    
-    return True
-
-def test_ray_address_construction():
-    """Test that Ray address is constructed correctly from environment variables."""
-    print("\nüîç Testing Ray address construction...")
-    
-    # Get values from environment
-    ray_host = os.getenv("RAY_HOST", "seedcore-svc-head-svc")
-    ray_port = os.getenv("RAY_PORT", "10001")
-    
-    # Construct address
-    ray_address = f"ray://{ray_host}:{ray_port}"
-    print(f"‚úÖ Constructed Ray address: {ray_address}")
-    
-    # Verify it's not the hardcoded value
-    if ray_address != "ray://ray-head:10001":
-        print("‚úÖ Address is not hardcoded - using environment variables")
-        return True
-    else:
-        print("‚ùå Address is still hardcoded")
+            print("‚ùå Ray connection failed!")
+            return False
+            
+    except Exception as e:
+        print(f"‚ùå Ray connection test failed: {e}")
         return False
 
-def test_ray_connection():
-    """Test that Ray connection can be established."""
-    print("\nüîç Testing Ray connection...")
+def test_agent_creation():
+    """Test agent creation using the tier0 manager."""
+    print("\nüß™ Testing agent creation...")
     
     try:
-        import ray
-        
-        # Get connection parameters from environment
-        ray_host = os.getenv("RAY_HOST", "seedcore-svc-head-svc")
-        ray_port = os.getenv("RAY_PORT", "10001")
-        ray_namespace = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
-        
-        # Construct address
-        ray_address = f"ray://{ray_host}:{ray_port}"
+        from seedcore.agents.tier0_manager import Tier0MemoryManager
         
-        print(f"üîó Attempting to connect to Ray at: {ray_address}")
-        print(f"üè∑Ô∏è Using namespace: {ray_namespace}")
+        # Create manager
+        manager = Tier0MemoryManager()
+        print("‚úÖ Tier0MemoryManager created successfully")
         
-        # Check if already connected
-        if ray.is_initialized():
-            print("‚ö†Ô∏è Ray already initialized, shutting down first...")
-            ray.shutdown()
-            time.sleep(1)
+        # Try to create a simple agent
+        agent_id = "test_agent_1"
+        role_probs = {"E": 0.8, "S": 0.1, "O": 0.1}
         
-        # Attempt connection
-        ray.init(address=ray_address, namespace=ray_namespace)
-        print("‚úÖ Ray connection established successfully!")
+        print(f"Creating agent: {agent_id}")
+        result = manager.create_agent(agent_id, role_probs)
+        print(f"‚úÖ Agent creation result: {result}")
         
-        # Test basic functionality
-        print("üß™ Testing Ray functionality...")
-        runtime_context = ray.get_runtime_context()
-        print(f"   - Ray Address: {runtime_context.gcs_address}")
-        print(f"   - Ray Namespace: {runtime_context.namespace}")
+        # List agents
+        agents = manager.list_agents()
+        print(f"‚úÖ Available agents: {agents}")
         
-        # Check cluster resources
-        try:
-            resources = ray.cluster_resources()
-            print(f"   - Cluster Resources: {resources}")
-        except Exception as e:
-            print(f"   - Could not get cluster resources: {e}")
-        
-        # Clean up
-        ray.shutdown()
-        print("‚úÖ Ray connection test completed successfully")
         return True
         
     except Exception as e:
-        print(f"‚ùå Failed to test Ray connection: {e}")
+        print(f"‚ùå Agent creation test failed: {e}")
+        import traceback
+        traceback.print_exc()
         return False
 
-def test_script_compatibility():
-    """Test that the fixed scripts can be imported without errors."""
-    print("\nüîç Testing script compatibility...")
-    
-    scripts_to_test = [
-        "scripts/job_detailed_analysis.py",
-        "scripts/debug_organ_actors.py",
-        "scripts/cleanup_organs.py",
-        "scripts/detailed_agent_placement.py",
-        "scripts/comprehensive_job_analysis.py",
-        "scripts/analyze_ray_jobs.py",
-        "scripts/analyze_agent_distribution.py",
-    ]
+def test_ray_status():
+    """Test Ray status and context."""
+    print("\nüß™ Testing Ray status...")
     
-    success_count = 0
-    for script_path in scripts_to_test:
-        try:
-            # Check if the script has the hardcoded address
-            with open(script_path, 'r') as f:
-                content = f.read()
-                
-            if "ray://ray-head:10001" in content:
-                print(f"‚ùå {script_path}: Still contains hardcoded address")
-            else:
-                print(f"‚úÖ {script_path}: Fixed - no hardcoded address")
-                success_count += 1
+    try:
+        import ray
+        
+        if ray.is_initialized():
+            print("‚úÖ Ray is initialized")
+            
+            # Get runtime context
+            runtime_context = ray.get_runtime_context()
+            print(f"‚úÖ Ray namespace: {getattr(runtime_context, 'namespace', 'unknown')}")
+            print(f"‚úÖ Ray address: {getattr(runtime_context, 'gcs_address', 'unknown')}")
+            
+            # Get cluster resources
+            try:
+                resources = ray.cluster_resources()
+                print(f"‚úÖ Cluster resources: {dict(resources)}")
+            except Exception as e:
+                print(f"‚ö†Ô∏è Could not get cluster resources: {e}")
                 
-        except Exception as e:
-            print(f"‚ö†Ô∏è {script_path}: Could not read - {e}")
-    
-    print(f"\nüìä Script compatibility: {success_count}/{len(scripts_to_test)} scripts fixed")
-    return success_count == len(scripts_to_test)
-
-def test_kubernetes_service_names():
-    """Test that the service names match what's expected in Kubernetes."""
-    print("\nüîç Testing Kubernetes service names...")
-    
-    # Expected service names based on the environment variables
-    expected_host = os.getenv("RAY_HOST", "seedcore-svc-head-svc")
-    expected_port = os.getenv("RAY_PORT", "10001")
-    
-    print(f"Expected Ray Head Service: {expected_host}:{expected_port}")
-    
-    # Check if this matches common patterns
-    if "seedcore" in expected_host and "head" in expected_host:
-        print("‚úÖ Service name follows expected pattern")
-        return True
-    else:
-        print("‚ö†Ô∏è Service name doesn't follow expected pattern")
+            return True
+        else:
+            print("‚ùå Ray is not initialized")
+            return False
+            
+    except Exception as e:
+        print(f"‚ùå Ray status test failed: {e}")
         return False
 
 def main():
     """Run all tests."""
-    print("üß™ Testing Ray Connection Fix")
-    print("=" * 60)
+    print("üöÄ Starting Ray connection fix tests...\n")
     
     tests = [
-        ("Environment Variables", test_environment_variables),
-        ("Ray Address Construction", test_ray_address_construction),
-        ("Ray Connection", test_ray_connection),
-        ("Script Compatibility", test_script_compatibility),
-        ("Kubernetes Service Names", test_kubernetes_service_names),
+        test_ray_connection,
+        test_ray_status,
+        test_agent_creation,
     ]
     
-    results = []
-    for test_name, test_func in tests:
-        print(f"\n{'='*50}")
-        print(f"Running: {test_name}")
-        print(f"{'='*50}")
-        
+    passed = 0
+    total = len(tests)
+    
+    for test in tests:
         try:
-            result = test_func()
-            results.append((test_name, result))
-            if result:
-                print(f"‚úÖ {test_name}: PASSED")
-            else:
-                print(f"‚ùå {test_name}: FAILED")
+            if test():
+                passed += 1
         except Exception as e:
-            print(f"‚ùå {test_name}: ERROR - {e}")
-            results.append((test_name, False))
-    
-    # Summary
-    print(f"\n{'='*60}")
-    print("TEST SUMMARY")
-    print(f"{'='*60}")
-    
-    passed = sum(1 for _, result in results if result)
-    total = len(results)
-    
-    for test_name, result in results:
-        status = "‚úÖ PASSED" if result else "‚ùå FAILED"
-        print(f"{test_name}: {status}")
+            print(f"‚ùå Test {test.__name__} crashed: {e}")
     
-    print(f"\nOverall: {passed}/{total} tests passed")
+    print(f"\nüìä Test Results: {passed}/{total} tests passed")
     
     if passed == total:
         print("üéâ All tests passed! The Ray connection fix is working correctly.")
-        print("\n‚úÖ The connection timeout error should now be resolved.")
-        print("‚úÖ Scripts should be able to connect to Ray using environment variables.")
         return 0
     else:
-        print("üí• Some tests failed. Please review the issues above.")
-        print("\nüîß The connection fix may need additional configuration.")
+        print("‚ö†Ô∏è Some tests failed. Check the output above for details.")
         return 1
 
 if __name__ == "__main__":
diff --git a/src/seedcore/agents/tier0_manager.py b/src/seedcore/agents/tier0_manager.py
index c436550..fe86964 100644
--- a/src/seedcore/agents/tier0_manager.py
+++ b/src/seedcore/agents/tier0_manager.py
@@ -21,6 +21,7 @@ import os
 import ray
 import time
 import asyncio
+from ..utils.ray_utils import ensure_ray_initialized
 from typing import Dict, List, Any, Optional
 from collections import defaultdict
 import logging
@@ -120,6 +121,9 @@ class Tier0MemoryManager:
             return agent_id
         
         try:
+            # Ensure Ray is initialized before creating actors
+            self._ensure_ray()
+            
             # Create the Ray actor
             options_kwargs: Dict[str, Any] = {}
             # Use a stable, detached, named actor when options are provided
@@ -135,8 +139,15 @@ class Tier0MemoryManager:
                 options_kwargs["num_gpus"] = num_gpus
             if resources:
                 options_kwargs["resources"] = resources
+            
+            # Set namespace if provided, otherwise use environment default
             if namespace:
                 options_kwargs["namespace"] = namespace
+            else:
+                # Get namespace from environment
+                env_namespace = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
+                if env_namespace:
+                    options_kwargs["namespace"] = env_namespace
 
             if options_kwargs:
                 agent_handle = RayAgent.options(**options_kwargs).remote(
@@ -156,6 +167,15 @@ class Tier0MemoryManager:
             
         except Exception as e:
             logger.error(f"Failed to create agent {agent_id}: {e}")
+            # Log additional debugging information
+            logger.error(f"Ray initialized: {ray.is_initialized()}")
+            if ray.is_initialized():
+                try:
+                    runtime_context = ray.get_runtime_context()
+                    logger.error(f"Ray namespace: {getattr(runtime_context, 'namespace', 'unknown')}")
+                    logger.error(f"Ray address: {getattr(runtime_context, 'gcs_address', 'unknown')}")
+                except Exception as ctx_e:
+                    logger.error(f"Failed to get Ray context: {ctx_e}")
             raise
     
     def create_agents_batch(self, agent_configs: List[Dict[str, Any]]) -> List[str]:
@@ -275,6 +295,7 @@ class Tier0MemoryManager:
     def _ensure_ray(self, ray_address: Optional[str] = None, ray_namespace: Optional[str] = None):
         """Ensure Ray is initialized with the correct address and namespace."""
         if ray.is_initialized():
+            logger.debug("Ray is already initialized, skipping connection")
             return
             
         # Get namespace from environment, default to "seedcore-dev" for consistency
@@ -287,16 +308,11 @@ class Tier0MemoryManager:
             ray_port = os.getenv("RAY_PORT", "10001")
             ray_address = f"ray://{ray_host}:{ray_port}"
         
-        # Always try to connect to the remote Ray cluster first
+        # Use the centralized Ray initialization utility
         logger.info(f"Attempting to connect to Ray cluster at: {ray_address}")
-        try:
-            ray.init(address=ray_address, ignore_reinit_error=True, namespace=ray_namespace)
-            logger.info(f"‚úÖ Ray initialized with remote address: {ray_address}, namespace: {ray_namespace}")
-        except Exception as e:
-            logger.warning(f"‚ö†Ô∏è Failed to connect to remote Ray cluster: {e}")
-            logger.warning("‚ö†Ô∏è Falling back to local Ray initialization")
-            ray.init(ignore_reinit_error=True, namespace=ray_namespace)
-            logger.info(f"‚úÖ Ray initialized locally, namespace: {ray_namespace}")
+        if not ensure_ray_initialized(ray_address=ray_address, ray_namespace=ray_namespace):
+            raise RuntimeError(f"Failed to initialize Ray connection (address={ray_address}, namespace={ray_namespace})")
+        logger.info(f"‚úÖ Ray connection established successfully")
 
     def _refresh_agents_from_cluster(self) -> None:
         """Discover and attach existing RayAgent actors from the Ray cluster.
diff --git a/src/seedcore/api/routers/organism_router.py b/src/seedcore/api/routers/organism_router.py
index 14aa487..51312f0 100644
--- a/src/seedcore/api/routers/organism_router.py
+++ b/src/seedcore/api/routers/organism_router.py
@@ -4,15 +4,19 @@ import time
 import ray
 from fastapi import APIRouter, HTTPException, Request
 
-from ...organs.organism_manager import organism_manager
+# SOLUTION: Remove module-level import to avoid accessing organism_manager before initialization
+# from ...organs.organism_manager import organism_manager
 
 
 router = APIRouter()
 
 
 def _get_manager_from_request(request: Request):
+    """Get the organism manager from the request's app state."""
     org = getattr(request.app.state, "organism", None)
-    return org if org is not None else organism_manager
+    if org is None:
+        raise HTTPException(status_code=503, detail="Organism not yet initialized. Please wait for startup to complete.")
+    return org
 
 
 @router.get("/organism/status")
@@ -31,25 +35,27 @@ async def get_organism_status(request: Request) -> Dict[str, Any]:
 @router.post("/organism/execute/{organ_id}")
 async def execute_task_on_organ(organ_id: str, request: Dict[str, Any]) -> Dict[str, Any]:
     try:
-        # Use global singleton to execute tasks; app state is set during startup
-        if not organism_manager.is_initialized():
+        # Use app state organism manager
+        org = _get_manager_from_request(request)
+        if not org.is_initialized():
             return {"success": False, "error": "Organism not initialized"}
 
         task_data = request.get("task_data", {})
-        result = await organism_manager.execute_task_on_organ(organ_id, task_data)
+        result = await org.execute_task_on_organ(organ_id, task_data)
         return result
     except Exception as e:
         return {"success": False, "error": str(e)}
 
 
 @router.post("/organism/execute/random")
-async def execute_task_on_random_organ(request: Dict[str, Any]) -> Dict[str, Any]:
+async def execute_task_on_random_organ(request: Request, task_request: Dict[str, Any]) -> Dict[str, Any]:
     try:
-        if not organism_manager.is_initialized():
+        org = _get_manager_from_request(request)
+        if not org.is_initialized():
             return {"success": False, "error": "Organism not initialized"}
 
-        task_data = request.get("task_data", {})
-        result = await organism_manager.execute_task_on_random_organ(task_data)
+        task_data = task_request.get("task_data", {})
+        result = await org.execute_task_on_random_organ(task_data)
         return result
     except Exception as e:
         return {"success": False, "error": str(e)}
@@ -87,14 +93,12 @@ async def get_organism_summary(request: Request) -> Dict[str, Any]:
 @router.post("/organism/initialize")
 async def initialize_organism(request: Request) -> Dict[str, Any]:
     try:
-        # Always use global manager; server startup also assigns it to app.state
-        if organism_manager.is_initialized():
-            # Ensure app state reflects global manager
-            setattr(request.app.state, "organism", organism_manager)
+        # Always use app state organism manager
+        org = _get_manager_from_request(request)
+        if org.is_initialized():
             return {"success": True, "message": "Organism already initialized"}
 
-        await organism_manager.initialize_organism()
-        setattr(request.app.state, "organism", organism_manager)
+        await org.initialize_organism()
         return {"success": True, "message": "Organism initialized successfully"}
     except Exception as e:
         return {"success": False, "error": str(e)}
diff --git a/src/seedcore/api/routers/tier0_router.py b/src/seedcore/api/routers/tier0_router.py
index a97fd8d..7334e70 100644
--- a/src/seedcore/api/routers/tier0_router.py
+++ b/src/seedcore/api/routers/tier0_router.py
@@ -2,6 +2,7 @@ from typing import Dict, Any
 import time
 import ray
 from fastapi import APIRouter
+from seedcore.utils.ray_connector import connect, is_connected
 
 from ...agents import Tier0MemoryManager, tier0_manager
 
@@ -159,17 +160,17 @@ async def debug_agent_discovery():
     except Exception:
         pass
 
-    # Ensure Ray connected
-    try:
-        if not ray.is_initialized():
-            addr = os.getenv("RAY_ADDRESS", "auto")
-            # Get namespace from environment, default to "seedcore-dev" for consistency
-            ns = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
-            ray.init(address=addr, ignore_reinit_error=True, namespace=ns)
-            details["ray"]["initialized"] = True
-            details["ray"]["namespace"] = ns
-    except Exception as e:
-        details["ray"]["error"] = str(e)
+            # Ensure Ray connected
+        try:
+            # SOLUTION: Use the centralized Ray connector
+            connect()  # This is idempotent and safe to call multiple times
+            if is_connected():
+                details["ray"]["initialized"] = True
+                details["ray"]["namespace"] = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
+            else:
+                details["ray"]["error"] = "Failed to connect to Ray"
+        except Exception as e:
+            details["ray"]["error"] = str(e)
 
     # List actors
     try:
diff --git a/src/seedcore/bootstrap.py b/src/seedcore/bootstrap.py
index 47012c3..6b9759a 100644
--- a/src/seedcore/bootstrap.py
+++ b/src/seedcore/bootstrap.py
@@ -14,6 +14,7 @@ from dataclasses import dataclass
 from typing import Any, Optional
 
 import ray
+# SOLUTION: Ray connection is now handled centrally by ray_connector.py
 
 # Import the ACTOR CLASSES (must be decorated with @ray.remote)
 from .memory.working_memory import MissTracker, SharedCache, MwStore  # type: ignore
@@ -60,11 +61,12 @@ def get_ray_namespace() -> str:
 
 
 def _ensure_ray(namespace: Optional[str]) -> None:
-    if ray.is_initialized():
-        return
-    # Initialize Ray if we are in a fresh driver process.
-    ray.init(address=CFG.ray_address, namespace=namespace)
-    logger.info("Ray initialized (address=%s, namespace=%s)", CFG.ray_address, namespace)
+    # SOLUTION: Ray connection is now handled centrally by ray_connector.py
+    # This function is kept for compatibility but no longer initializes Ray
+    if not ray.is_initialized():
+        logger.critical("‚ùå Ray not initialized. This should not happen - Ray should be initialized at application startup.")
+        raise RuntimeError("Ray not initialized - application startup issue")
+    logger.info("‚úÖ Ray connection verified (namespace=%s)", namespace)
 
 
 # -----------------------------------------------------------------------------
@@ -78,32 +80,52 @@ def _get_or_create(actor_cls: Any, name: str, **options: Any):
     use it for idempotent creation; otherwise fall back to create+lookup.
     """
     ns = get_ray_namespace()
+    logger.info(f"üîç Creating actor '{name}' in namespace '{ns}'")
+    
     _ensure_ray(ns)
 
     # Fast path: already exists
     try:
-        return ray.get_actor(name, namespace=ns)
-    except Exception:
-        pass
+        logger.info(f"üîç Checking if actor '{name}' already exists...")
+        existing_actor = ray.get_actor(name, namespace=ns)
+        logger.info(f"‚úÖ Actor '{name}' already exists: {existing_actor}")
+        return existing_actor
+    except Exception as e:
+        logger.info(f"üîç Actor '{name}' not found: {e}")
 
     # Try to create (idempotent if get_if_exists is available)
     try:
-        return (
+        logger.info(f"üöÄ Creating actor '{name}' with class {actor_cls.__name__}...")
+        actor_handle = (
             actor_cls.options(
                 name=name, namespace=ns, lifetime="detached", get_if_exists=True, **options
             ).remote()
         )
+        logger.info(f"‚úÖ Successfully created actor '{name}': {actor_handle}")
+        return actor_handle
     except TypeError:
         # Older Ray without get_if_exists
+        logger.info(f"‚ö†Ô∏è Ray version doesn't support get_if_exists, falling back...")
         try:
             handle = actor_cls.options(name=name, namespace=ns, lifetime="detached", **options).remote()
+            logger.info(f"‚úÖ Created actor '{name}' (fallback): {handle}")
             return handle
-        except Exception:
+        except Exception as e:
+            logger.info(f"‚ö†Ô∏è Failed to create actor '{name}' (fallback): {e}")
             # Lost the race: someone else created it
-            return ray.get_actor(name, namespace=ns)
-    except Exception:
+            try:
+                return ray.get_actor(name, namespace=ns)
+            except Exception as get_e:
+                logger.error(f"‚ùå Failed to get actor '{name}' after creation failure: {get_e}")
+                raise
+    except Exception as e:
+        logger.error(f"‚ùå Failed to create actor '{name}': {e}")
         # Lost the race or transient error
-        return ray.get_actor(name, namespace=ns)
+        try:
+            return ray.get_actor(name, namespace=ns)
+        except Exception as get_e:
+            logger.error(f"‚ùå Failed to get actor '{name}' after creation failure: {get_e}")
+            raise
 
 
 # -----------------------------------------------------------------------------
@@ -112,10 +134,29 @@ def _get_or_create(actor_cls: Any, name: str, **options: Any):
 
 def bootstrap_actors():
     """Ensure all singleton actors exist; return handles as a tuple."""
-    miss_tracker = _get_or_create(MissTracker, "miss_tracker")
-    shared_cache = _get_or_create(SharedCache, "shared_cache")
-    mw_store = _get_or_create(MwStore, "mw")
-    return miss_tracker, shared_cache, mw_store
+    logger.info("üöÄ Starting bootstrap of singleton actors...")
+    
+    try:
+        logger.info("üîç Creating miss_tracker actor...")
+        miss_tracker = _get_or_create(MissTracker, "miss_tracker")
+        logger.info("‚úÖ miss_tracker created: {miss_tracker}")
+        
+        logger.info("üîç Creating shared_cache actor...")
+        shared_cache = _get_or_create(SharedCache, "shared_cache")
+        logger.info("‚úÖ shared_cache created: {shared_cache}")
+        
+        logger.info("üîç Creating mw_store actor...")
+        mw_store = _get_or_create(MwStore, "mw")
+        logger.info("‚úÖ mw_store created: {mw_store}")
+        
+        logger.info("üéâ All singleton actors bootstrapped successfully!")
+        return miss_tracker, shared_cache, mw_store
+        
+    except Exception as e:
+        logger.error(f"‚ùå Bootstrap failed: {e}")
+        import traceback
+        logger.error(f"‚ùå Traceback: {traceback.format_exc()}")
+        raise
 
 
 # Convenience accessors (match names used elsewhere in the codebase)
diff --git a/src/seedcore/cognitive/dspy_client.py b/src/seedcore/cognitive/dspy_client.py
index b7fdccc..70c5624 100644
--- a/src/seedcore/cognitive/dspy_client.py
+++ b/src/seedcore/cognitive/dspy_client.py
@@ -15,6 +15,7 @@ from typing import Any, Dict, Mapping, Optional
 import ray
 from ray import serve
 from ray.exceptions import RayActorError
+from seedcore.utils.ray_utils import ensure_ray_initialized
 
 JSONDict = Dict[str, Any]
 
@@ -103,74 +104,11 @@ class DSpyCognitiveClient:
         
         self._logger.info("Connecting to Ray cluster...")
         
-        # Check if Ray is already initialized (possibly by serve import)
-        if ray.is_initialized():
-            self._logger.info("Ray already initialized, checking connection...")
-            try:
-                runtime_context = ray.get_runtime_context()
-                self._logger.info("Existing Ray runtime context: %s", runtime_context)
-                
-                # Check if we're connected to the right cluster
-                if hasattr(runtime_context, 'worker') and hasattr(runtime_context.worker, 'worker_id'):
-                    worker_id = runtime_context.worker.worker_id
-                    self._logger.info("Connected to Ray worker: %s", worker_id)
-                    
-                    # If we're connected to a local worker, try to reconnect to remote cluster
-                    if '127.0.0.1' in str(worker_id) or 'localhost' in str(worker_id):
-                        self._logger.warning("Connected to local Ray instance, attempting to reconnect to remote cluster...")
-                        ray.shutdown()
-                        self._logger.info("Local Ray instance shut down, reconnecting to remote cluster...")
-                        ray.init(address=self.config.ray_address, ignore_reinit_error=True, namespace=_env_ns())
-                        self._logger.info("Successfully reconnected to remote Ray cluster")
-                    else:
-                        self._logger.info("Already connected to remote Ray cluster")
-                else:
-                    self._logger.info("Ray runtime context doesn't have worker info")
-                    
-            except Exception as e:
-                self._logger.warning("Error checking existing Ray connection: %s", e)
-                # Try to reconnect to remote cluster
-                try:
-                    ray.shutdown()
-                    self._logger.info("Reconnecting to remote Ray cluster...")
-                    ray.init(address=self.config.ray_address, ignore_reinit_error=True, namespace=_env_ns())
-                    self._logger.info("Successfully reconnected to remote Ray cluster")
-                except Exception as reconnect_e:
-                    self._logger.error("Failed to reconnect to remote Ray cluster: %s", reconnect_e)
-                    raise ConnectionError(f"Failed to connect to Ray cluster at {self.config.ray_address}: {reconnect_e}")
-        else:
-            try:
-                self._logger.info("Initializing Ray with address: %s, namespace: %s", self.config.ray_address, _env_ns())
-                self._logger.info("Ray environment variables: RAY_HOST=%s, RAY_PORT=%s, RAY_NAMESPACE=%s", 
-                                os.getenv('RAY_HOST'), os.getenv('RAY_PORT'), os.getenv('RAY_NAMESPACE'))
-                
-                # Try to connect to remote Ray cluster
-                ray.init(address=self.config.ray_address, ignore_reinit_error=True, namespace=_env_ns())
-                
-                # Verify we're connected to the remote cluster
-                runtime_context = ray.get_runtime_context()
-                self._logger.info("Ray runtime context: %s", runtime_context)
-                if hasattr(runtime_context, 'worker') and hasattr(runtime_context.worker, 'worker_id'):
-                    self._logger.info("Ray cluster address: %s", runtime_context.worker.worker_id)
-                
-                self._logger.info("Ray initialized successfully")
-            except Exception as e:
-                self._logger.error("Failed to initialize Ray with address %s: %s", self.config.ray_address, e)
-                self._logger.error("Exception type: %s", type(e).__name__)
-                import traceback
-                self._logger.error("Full traceback: %s", traceback.format_exc())
-                # Don't fall back to local Ray initialization in production
-                # This would cause the client to look for applications in the wrong place
-                raise ConnectionError(f"Failed to connect to Ray cluster at {self.config.ray_address}: {e}")
-        
-        try:
-            self._logger.info("Connecting to Ray Serve...")
-            # In newer Ray versions, serve.connect() is not needed
-            # The connection is established when ray.init() succeeds
-            self._logger.info("Ray Serve connection established")
-        except Exception as exc:
-            self._logger.warning("Ray Serve connection warning: %s", exc)
+        # Use the centralized Ray initialization utility
+        if not ensure_ray_initialized(ray_address=self.config.ray_address, ray_namespace=_env_ns()):
+            raise ConnectionError(f"Failed to connect to Ray cluster at {self.config.ray_address}")
         
+        self._logger.info("Ray connection established successfully")
         self._is_connected = True
         self._logger.info("Connection setup completed")
 
diff --git a/src/seedcore/control/flywheel.py b/src/seedcore/control/flywheel.py
index 7e03169..0277517 100644
--- a/src/seedcore/control/flywheel.py
+++ b/src/seedcore/control/flywheel.py
@@ -25,7 +25,8 @@ from typing import Dict, Any, List, Optional
 from dataclasses import dataclass
 
 from ..energy.api import _ledger
-from ..organs.organism_manager import organism_manager
+# SOLUTION: Remove module-level import to avoid accessing organism_manager before initialization
+# from ..organs.organism_manager import organism_manager
 
 logger = logging.getLogger(__name__)
 
@@ -294,17 +295,25 @@ class HourlyFlywheel:
             logger.error(f"Error getting flywheel stats: {e}")
             return {"error": str(e)}
 
-# Global flywheel instance
-flywheel = HourlyFlywheel(organism_manager, _ledger)
+# Global flywheel instance - lazy initialization to avoid accessing organism_manager before it's ready
+_flywheel_instance = None
+
+def get_flywheel_instance():
+    """Get the global flywheel instance with lazy initialization."""
+    global _flywheel_instance
+    if _flywheel_instance is None:
+        # Lazy import to avoid circular dependencies
+        from ..organs.organism_manager import organism_manager
+        if organism_manager is None:
+            raise RuntimeError("OrganismManager not yet initialized. Please wait for startup to complete.")
+        _flywheel_instance = HourlyFlywheel(organism_manager, _ledger)
+    return _flywheel_instance
 
 async def start_flywheel():
     """Start the global flywheel instance."""
-    await flywheel.start()
+    get_flywheel_instance().start()
 
 async def stop_flywheel():
     """Stop the global flywheel instance."""
-    await flywheel.stop()
-
-def get_flywheel_instance():
-    """Get the global flywheel instance."""
-    return flywheel 
\ No newline at end of file
+    if _flywheel_instance is not None:
+        await _flywheel_instance.stop() 
\ No newline at end of file
diff --git a/src/seedcore/energy/control_loops.py b/src/seedcore/energy/control_loops.py
index 9a2109d..7ee0e03 100644
--- a/src/seedcore/energy/control_loops.py
+++ b/src/seedcore/energy/control_loops.py
@@ -25,7 +25,8 @@ from typing import Dict, Any, List, Optional
 from dataclasses import dataclass
 
 from .ledger import EnergyLedger
-from ..organs.organism_manager import organism_manager
+# SOLUTION: Remove module-level import to avoid accessing organism_manager before initialization
+# from ..organs.organism_manager import organism_manager
 
 logger = logging.getLogger(__name__)
 
@@ -310,17 +311,25 @@ class SlowPSOLoop:
         L_tot = min(0.999, (p_fast * 1.0 + (1.0 - p_fast) * beta_meta) * rho * beta_mem)
         return L_tot
 
-# Global instance
-slow_psoloop = SlowPSOLoop(EnergyLedger(), organism_manager)
+# Global instance - lazy initialization to avoid accessing organism_manager before it's ready
+_slow_psoloop_instance = None
+
+def get_slow_psoloop_instance():
+    """Get the global slow PSO loop instance with lazy initialization."""
+    global _slow_psoloop_instance
+    if _slow_psoloop_instance is None:
+        # Lazy import to avoid circular dependencies
+        from ..organs.organism_manager import organism_manager
+        if organism_manager is None:
+            raise RuntimeError("OrganismManager not yet initialized. Please wait for startup to complete.")
+        _slow_psoloop_instance = SlowPSOLoop(EnergyLedger(), organism_manager)
+    return _slow_psoloop_instance
 
 def start_slow_psoloop():
     """Start the global slow PSO loop instance."""
-    slow_psoloop.start()
+    get_slow_psoloop_instance().start()
 
 def stop_slow_psoloop():
     """Stop the global slow PSO loop instance."""
-    slow_psoloop.stop()
-
-def get_slow_psoloop_instance():
-    """Get the global slow PSO loop instance."""
-    return slow_psoloop 
\ No newline at end of file
+    if _slow_psoloop_instance is not None:
+        _slow_psoloop_instance.stop() 
\ No newline at end of file
diff --git a/src/seedcore/memory/working_memory.py b/src/seedcore/memory/working_memory.py
index 2760ec9..fcd9d18 100644
--- a/src/seedcore/memory/working_memory.py
+++ b/src/seedcore/memory/working_memory.py
@@ -27,6 +27,7 @@ from dataclasses import dataclass
 from typing import Any, Dict, List, Optional, Tuple
 
 import ray
+from ..utils.ray_utils import ensure_ray_initialized
 
 try:
     # Prefer the project-provided namespace helper if available
@@ -138,7 +139,8 @@ class SharedCache:
 def _ensure_ray(namespace: Optional[str]) -> None:
     if ray.is_initialized():
         return
-    ray.init(address=CONFIG.ray_address, namespace=namespace)
+    if not ensure_ray_initialized(ray_address=CONFIG.ray_address, ray_namespace=namespace):
+        raise RuntimeError(f"Failed to initialize Ray (address={CONFIG.ray_address}, namespace={namespace})")
     logger.info(
         "Ray initialized: address=%s namespace=%s",
         CONFIG.ray_address,
diff --git a/src/seedcore/ml/models/xgboost_service.py b/src/seedcore/ml/models/xgboost_service.py
index 2ec7e9c..de9a95d 100644
--- a/src/seedcore/ml/models/xgboost_service.py
+++ b/src/seedcore/ml/models/xgboost_service.py
@@ -8,6 +8,7 @@ It integrates seamlessly with the existing SeedCore ML service architecture.
 import ray
 import pandas as pd
 import numpy as np
+from ...utils.ray_utils import ensure_ray_initialized
 import xgboost as xgb
 import logging
 import time
@@ -87,28 +88,11 @@ class XGBoostService:
         # Initialize Ray if not already initialized
         # When running in the Ray head container, we should connect to the existing Ray instance
         if not ray.is_initialized():
-            # Check if we're in the Ray head container by looking for Ray processes
-            import subprocess
-            try:
-                result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
-                if 'ray' in result.stdout and ('gcs_server' in result.stdout or 'raylet' in result.stdout):
-                    # We're in the head container, connect to the existing Ray instance
-                    ray.init()
-                    logger.info("‚úÖ Connected to existing Ray instance in head container")
-                else:
-                    # We're in a worker or external environment, connect via RAY_ADDRESS
-                    ray_address = os.getenv("RAY_ADDRESS")
-                    if ray_address:
-                        ray.init(address=ray_address, log_to_driver=False)
-                        logger.info(f"‚úÖ Connected to Ray cluster at {ray_address}")
-                    else:
-                        # Fallback to local initialization if RAY_ADDRESS not set
-                        ray.init()
-                        logger.info("‚úÖ Connected to local Ray instance")
-            except Exception:
-                # Fallback to simple initialization
-                ray.init()
-                logger.info("‚úÖ Connected to Ray instance (fallback)")
+            # Use the centralized Ray initialization utility
+            ray_address = os.getenv("RAY_ADDRESS")
+            if not ensure_ray_initialized(ray_address=ray_address):
+                raise RuntimeError("Failed to initialize Ray connection")
+            logger.info("‚úÖ Ray connection established successfully")
         else:
             logger.info("‚úÖ Ray is already initialized, skipping initialization")
         
diff --git a/src/seedcore/ml/tuning_service.py b/src/seedcore/ml/tuning_service.py
index c21ac2a..9abfeec 100644
--- a/src/seedcore/ml/tuning_service.py
+++ b/src/seedcore/ml/tuning_service.py
@@ -9,6 +9,7 @@ import ray
 import requests
 import logging
 import time
+from ..utils.ray_utils import ensure_ray_initialized
 import json
 import shutil
 from pathlib import Path
@@ -134,21 +135,11 @@ class HyperparameterTuningService:
         
         # Initialize Ray if not already initialized
         if not ray.is_initialized():
-            try:
-                # Try to connect to existing Ray cluster
-                ray.init(address="ray://localhost:10001", log_to_driver=False)
-                logger.info("‚úÖ Connected to existing Ray cluster")
-            except Exception as e:
-                logger.warning(f"‚ö†Ô∏è Failed to connect to existing Ray cluster: {e}")
-                try:
-                    # Try alternative address format
-                    ray.init(address="localhost:10001", log_to_driver=False)
-                    logger.info("‚úÖ Connected to Ray cluster with alternative address")
-                except Exception as e2:
-                    logger.warning(f"‚ö†Ô∏è Failed to connect with alternative address: {e2}")
-                    # Fallback to local initialization
-                    ray.init()
-                    logger.info("‚úÖ Initialized local Ray instance")
+            # Use the centralized Ray initialization utility
+            ray_address = os.getenv("RAY_ADDRESS", "ray://localhost:10001")
+            if not ensure_ray_initialized(ray_address=ray_address):
+                raise RuntimeError("Failed to initialize Ray connection")
+            logger.info("‚úÖ Ray connection established successfully")
         
         # Initialize flashbulb client for logging high-impact events
         try:
diff --git a/src/seedcore/organs/__init__.py b/src/seedcore/organs/__init__.py
index 5c305c3..2c4943f 100644
--- a/src/seedcore/organs/__init__.py
+++ b/src/seedcore/organs/__init__.py
@@ -15,6 +15,8 @@
 """Organs subpackage for COA framework."""
 
 from .base import Organ
-from .organism_manager import OrganismManager, organism_manager
+from .organism_manager import OrganismManager
+# SOLUTION: Remove module-level import to avoid accessing organism_manager before initialization
+# from .organism_manager import organism_manager
 
-__all__ = ['Organ', 'OrganismManager', 'organism_manager']
+__all__ = ['Organ', 'OrganismManager']
diff --git a/src/seedcore/organs/organism_manager.py b/src/seedcore/organs/organism_manager.py
index c6fddce..4861f50 100644
--- a/src/seedcore/organs/organism_manager.py
+++ b/src/seedcore/organs/organism_manager.py
@@ -31,11 +31,12 @@ import time
 import ray
 import os
 import concurrent.futures
+# SOLUTION: Ray connection is now handled centrally by ray_connector.py
 import traceback
 import random
 from pathlib import Path
 from dataclasses import dataclass, field
-from typing import Dict, List, Any, Optional, Tuple, Set
+from typing import Dict, List, Any, Optional, Tuple, Set, TYPE_CHECKING
 # Note: ray.util.state APIs don't work with Ray client connections
 # from ray.util.state import list_actors, list_nodes
 
@@ -120,99 +121,19 @@ class OrganismManager:
         self._load_config(config_path)
         self._initialized = False
         
-        # Initialize Ray connection if not already initialized
-        self._ensure_ray()
-
-        # Bootstrap required singleton actors (mw, miss_tracker, shared_cache)
-        try:
-            from ..bootstrap import bootstrap_actors
-            logger.info("üöÄ Bootstrapping required singleton actors...")
-            bootstrap_actors()
-            logger.info("‚úÖ Singleton actors bootstrapped successfully")
-        except Exception as e:
-            logger.warning(f"‚ö†Ô∏è Failed to bootstrap singleton actors: {e}")
-            logger.warning("‚ö†Ô∏è Agents may have limited functionality without memory managers")
-
-        # COA ¬ß6: Initialize routing components
+        # Initialize routing components (these don't depend on Ray)
         self.ocps = OCPSValve()
         self.routing = RoutingTable()
         self.organ_interfaces: Dict[str, StandardizedOrganInterface] = {}
-
-    def _ensure_ray(self):
-        """Ensure Ray is properly initialized with the correct address."""
         
-        try:
-            if not ray.is_initialized():
-                # Get Ray connection parameters from environment
-                ray_host = os.getenv("RAY_HOST", "seedcore-svc-head-svc")
-                ray_port = os.getenv("RAY_PORT", "10001")
-                ray_address = f"ray://{ray_host}:{ray_port}"
-                
-                # Get namespace from environment, default to "seedcore-dev" for consistency
-                ray_namespace = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
-                
-                # Always try to connect to the remote Ray cluster first
-                logger.info(f"Attempting to connect to Ray cluster at: {ray_address}")
-                try:
-                    ray.init(address=ray_address, ignore_reinit_error=True, namespace=ray_namespace)
-                    logger.info("‚úÖ Ray initialized successfully with remote address")
-                except Exception as e:
-                    logger.warning(f"‚ö†Ô∏è Failed to connect to remote Ray cluster: {e}")
-                    logger.warning("‚ö†Ô∏è Falling back to local Ray initialization")
-                    ray.init(ignore_reinit_error=True, namespace=ray_namespace)
-                    logger.info("‚úÖ Ray initialized locally")
-            else:
-                logger.info("‚úÖ Ray is already initialized")
-                
-            # Verify namespace is correct and force if needed
-            self._verify_and_enforce_namespace()
-            
-        except Exception as e:
-            logger.error(f"‚ùå Failed to initialize Ray: {e}")
-            raise
+        # Note: Ray-dependent initialization is now handled in initialize_organism()
+        # This constructor is safe to call before Ray is ready
+
+    # SOLUTION: Ray connection is now handled centrally by ray_connector.py
+    # This method is no longer needed and has been removed.
     
-    def _verify_and_enforce_namespace(self):
-        """Verify that Ray is using the correct namespace and enforce if needed."""
-        try:
-            expected_namespace = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
-            runtime_context = ray.get_runtime_context()
-            current_namespace = getattr(runtime_context, 'namespace', 'unknown')
-            
-            logger.info(f"üîç Namespace verification: expected='{expected_namespace}', current='{current_namespace}'")
-            
-            if current_namespace != expected_namespace:
-                logger.warning(f"‚ö†Ô∏è  WARNING: Ray namespace mismatch!")
-                logger.warning(f"   Expected: {expected_namespace}")
-                logger.warning(f"   Current:  {current_namespace}")
-                logger.warning(f"   This may cause actors to be created in the wrong namespace")
-                
-                # Try to force namespace by reinitializing Ray
-                if current_namespace == 'unknown' or current_namespace != expected_namespace:
-                    logger.info(f"üîÑ Attempting to force correct namespace by reinitializing Ray...")
-                    try:
-                        ray.shutdown()
-                        
-                        # Try to reconnect to the remote cluster with correct namespace
-                        ray_host = os.getenv("RAY_HOST", "seedcore-svc-head-svc")
-                        ray_port = os.getenv("RAY_PORT", "10001")
-                        ray_address = f"ray://{ray_host}:{ray_port}"
-                        
-                        ray.init(address=ray_address, namespace=expected_namespace, ignore_reinit_error=True)
-                        new_runtime_context = ray.get_runtime_context()
-                        new_namespace = getattr(new_runtime_context, 'namespace', 'unknown')
-                        logger.info(f"üîß Ray reinitialized with namespace: {new_namespace}")
-                        
-                        if new_namespace == expected_namespace:
-                            logger.info("‚úÖ Successfully forced correct namespace")
-                        else:
-                            logger.error(f"‚ùå Failed to force correct namespace: {new_namespace}")
-                    except Exception as e:
-                        logger.error(f"‚ùå Failed to reinitialize Ray: {e}")
-            else:
-                logger.info("‚úÖ Ray namespace is correct")
-                
-        except Exception as e:
-            logger.warning(f"‚ö†Ô∏è  Could not verify/enforce namespace: {e}")
+    # SOLUTION: Namespace verification is now handled centrally by ray_connector.py
+    # This method is no longer needed and has been removed.
 
     def _load_config(self, config_path: str):
         """Loads the organism configuration from a YAML file."""
@@ -235,7 +156,7 @@ class OrganismManager:
     def _check_ray_cluster_health(self):
         """Check Ray cluster health and log diagnostic information."""
         try:
-            # Check cluster resources
+            # Check cluster resources (available with Ray client)
             cluster_resources = ray.cluster_resources()
             available_resources = ray.available_resources()
             
@@ -252,33 +173,23 @@ class OrganismManager:
             if available_cpu < 1.0:
                 logger.warning(f"‚ö†Ô∏è Low CPU availability: {available_cpu}/{total_cpu} CPUs available")
             
-            # Check nodes
+            # Note: list_nodes() and list_actors() are not available with Ray client connections
+            # We can only check basic cluster resources and test actor communication
+            
+            # Test basic Ray functionality with a simple remote task
             try:
-                nodes = list_nodes()
-                logger.info(f"üñ•Ô∏è Ray nodes: {len(nodes)} total")
-                alive_nodes = 0
-                for node in nodes:
-                    if node.state == "ALIVE":
-                        alive_nodes += 1
-                    logger.info(f"   - Node {node.node_id}: {node.state} (CPU: {node.cpu_count})")
+                @ray.remote
+                def _health_check_task():
+                    return "healthy"
                 
-                if alive_nodes == 0:
-                    raise Exception("No alive nodes in Ray cluster")
+                result = ray.get(_health_check_task.remote())
+                if result == "healthy":
+                    logger.info("‚úÖ Ray remote task execution test passed")
+                else:
+                    logger.warning(f"‚ö†Ô∏è Ray remote task test returned unexpected result: {result}")
                     
             except Exception as e:
-                logger.warning(f"Could not list nodes: {e}")
-            
-            # Check actors
-            try:
-                actors = list_actors()
-                logger.info(f"üé≠ Ray actors: {len(actors)} total")
-                dead_actors = [actor for actor in actors if actor.state == "DEAD"]
-                if dead_actors:
-                    logger.warning(f"‚ö†Ô∏è Found {len(dead_actors)} dead actors")
-                    for actor in dead_actors[:5]:  # Log first 5 dead actors
-                        logger.warning(f"   - Dead actor: {actor.actor_id} ({actor.class_name})")
-            except Exception as e:
-                logger.warning(f"Could not list actors: {e}")
+                logger.warning(f"Ray remote task test failed: {e}")
                 
             logger.info("‚úÖ Ray cluster health check completed")
             
@@ -294,30 +205,11 @@ class OrganismManager:
                 logger.info("Ray not initialized, skipping dead actor cleanup")
                 return
             
-            # Get all actors with timeout
-            try:
-                actors = list_actors()
-                dead_actors = [actor for actor in actors if actor.state == "DEAD"]
-                
-                if dead_actors:
-                    logger.info(f"üßπ Found {len(dead_actors)} dead actors, cleaning up...")
-                    
-                    for actor in dead_actors:
-                        try:
-                            if hasattr(actor, 'actor_id'):
-                                # Try to kill the dead actor
-                                ray.kill(actor.actor_id)
-                                logger.debug(f"üóëÔ∏è Cleaned up dead actor: {actor.actor_id}")
-                        except Exception as e:
-                            logger.debug(f"Could not clean up dead actor {actor.actor_id}: {e}")
-                            
-                    logger.info(f"‚úÖ Cleaned up {len(dead_actors)} dead actors")
-                else:
-                    logger.info("‚úÖ No dead actors found")
-                    
-            except Exception as e:
-                logger.warning(f"Could not list actors: {e}")
-                
+            # Note: list_actors() is not available with Ray client connections
+            # We can only clean up actors we have handles to
+            logger.info("‚ö†Ô∏è Dead actor cleanup limited with Ray client connections")
+            logger.info("‚ö†Ô∏è Only actors with known handles can be cleaned up")
+            
         except Exception as e:
             logger.warning(f"Could not clean up dead actors: {e}")
 
@@ -876,6 +768,20 @@ class OrganismManager:
             
         logger.info("üöÄ Initializing the Cognitive Organism...")
         
+        # Verify Ray is ready before proceeding
+        if not ray.is_initialized():
+            raise RuntimeError("Ray is not initialized. Please ensure Ray connection is established before calling initialize_organism.")
+        
+        # Bootstrap required singleton actors
+        try:
+            logger.info("üöÄ Bootstrapping required singleton actors...")
+            from ..bootstrap import bootstrap_actors
+            bootstrap_actors()
+            logger.info("‚úÖ Singleton actors bootstrapped successfully")
+        except Exception as e:
+            logger.error(f"‚ö†Ô∏è Failed to bootstrap singleton actors: {e}", exc_info=True)
+            logger.warning("‚ö†Ô∏è Agents may have limited functionality without memory managers")
+        
         max_retries = 3
         retry_delay = 10  # seconds
         
@@ -883,9 +789,6 @@ class OrganismManager:
             try:
                 logger.info(f"üîÑ Attempt {attempt + 1}/{max_retries} to initialize organism...")
                 
-                # Ensure Ray is properly initialized before proceeding
-                self._ensure_ray()
-                
                 # Check Ray cluster health before proceeding
                 self._check_ray_cluster_health()
                 
@@ -931,4 +834,5 @@ class OrganismManager:
         logger.info("‚úÖ Organism shutdown complete")
 
 # Global instance for easy access from the API server
-organism_manager = OrganismManager() 
\ No newline at end of file
+# SOLUTION: Lazy initialization - this will be created by FastAPI lifespan after Ray is connected
+organism_manager: Optional[OrganismManager] = None 
\ No newline at end of file
diff --git a/src/seedcore/serve/simple_app.py b/src/seedcore/serve/simple_app.py
index 382abee..f75d271 100644
--- a/src/seedcore/serve/simple_app.py
+++ b/src/seedcore/serve/simple_app.py
@@ -7,6 +7,7 @@ This provides basic health monitoring without requiring full database connection
 import ray
 from ray import serve
 from fastapi import FastAPI
+from ..utils.ray_utils import ensure_ray_initialized
 import logging
 import os
 from typing import Dict, Any
@@ -97,7 +98,8 @@ class SeedCoreHealthService:
             if not ray.is_initialized():
                 # Get namespace from environment, default to "seedcore-dev" for consistency
                 ray_namespace = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
-                ray.init(address="auto", namespace=ray_namespace)
+                if not ensure_ray_initialized(ray_namespace=ray_namespace):
+                    raise RuntimeError(f"Failed to initialize Ray connection (namespace={ray_namespace})")
                 logger.info("‚úÖ Ray initialized successfully")
             else:
                 logger.info("‚úÖ Ray already initialized")
diff --git a/src/seedcore/telemetry/metrics_integration.py b/src/seedcore/telemetry/metrics_integration.py
index a4e96e9..24c27e0 100644
--- a/src/seedcore/telemetry/metrics_integration.py
+++ b/src/seedcore/telemetry/metrics_integration.py
@@ -4,6 +4,8 @@ Metrics Integration Service
 This service automatically updates Prometheus metrics by polling the rich API endpoints
 and converting the data into Prometheus format. This leverages the existing comprehensive
 API endpoints without requiring additional instrumentation.
+
+When running on the same server, it can access app state directly for better performance.
 """
 
 import asyncio
@@ -25,19 +27,29 @@ class MetricsIntegrationService:
     
     This approach leverages the rich API endpoints we already have instead of
     instrumenting every component individually.
+    
+    When running on the same server, it can access app state directly for better performance.
     """
     
-    def __init__(self, base_url: str = "http://localhost:80", update_interval: int = 30):
+    def __init__(self, base_url: str = "http://localhost:80", update_interval: int = 30, app_state=None):
         self.base_url = base_url.rstrip('/')
         self.update_interval = update_interval
+        self.app_state = app_state  # FastAPI app state for local access
         self.session: Optional[aiohttp.ClientSession] = None
         self.running = False
         
+        # Check if we're running locally (same server)
+        # Normalize base_url for comparison
+        normalized_url = base_url.lower().replace('http://', '').replace('https://', '')
+        self.is_local = normalized_url in ["localhost:80", "localhost:8002", "127.0.0.1:80", "127.0.0.1:8002", "0.0.0.0:8002"]
+        
     async def start(self):
         """Start the metrics integration service."""
-        self.session = aiohttp.ClientSession()
+        if not self.is_local:
+            self.session = aiohttp.ClientSession()
+        
         self.running = True
-        logger.info(f"üöÄ Starting Metrics Integration Service (interval: {self.update_interval}s)")
+        logger.info(f"üöÄ Starting Metrics Integration Service (interval: {self.update_interval}s, mode: {'local' if self.is_local else 'remote'})")
         
         while self.running:
             try:
@@ -56,6 +68,63 @@ class MetricsIntegrationService:
     
     async def _fetch_endpoint(self, endpoint: str) -> Optional[Dict[str, Any]]:
         """Fetch data from an API endpoint with metrics tracking."""
+        if self.is_local and self.app_state:
+            # Use local app state for better performance
+            return await self._get_local_data(endpoint)
+        elif self.session:
+            # Use HTTP calls for remote services
+            return await self._fetch_remote_endpoint(endpoint)
+        else:
+            logger.warning(f"Cannot fetch {endpoint}: no session or app state available")
+            return None
+    
+    async def _get_local_data(self, endpoint: str) -> Optional[Dict[str, Any]]:
+        """Get data from local app state instead of HTTP calls."""
+        try:
+            if endpoint == "/energy/gradient":
+                # Access energy data from app state
+                if hasattr(self.app_state, 'energy_weights'):
+                    return {"energy_weights": self.app_state.energy_weights}
+                return {"energy_weights": None}
+                
+            elif endpoint == "/tier0/agents/state":
+                # Access agent data from app state
+                if hasattr(self.app_state, 'organism') and self.app_state.organism:
+                    try:
+                        # Get agent states from organism manager
+                        agent_states = {}
+                        # This would need to be implemented based on your agent structure
+                        return {"agents": agent_states}
+                    except Exception as e:
+                        logger.debug(f"Could not get agent states: {e}")
+                        return {"agents": {}}
+                return {"agents": {}}
+                
+            elif endpoint == "/system/status":
+                # Access system status from app state
+                status = {
+                    "ray_connected": hasattr(self.app_state, 'organism') and self.app_state.organism is not None,
+                    "memory_system": hasattr(self.app_state, 'mem'),
+                    "organism_initialized": hasattr(self.app_state, 'organism') and getattr(self.app_state.organism, '_initialized', False) if self.app_state.organism else False
+                }
+                return status
+                
+            elif endpoint == "/energy/monitor":
+                # Access energy monitoring data from app state
+                if hasattr(self.app_state, 'energy_weights'):
+                    return {"energy_weights_available": True}
+                return {"energy_weights_available": False}
+                
+            else:
+                logger.warning(f"Unknown local endpoint: {endpoint}")
+                return None
+                
+        except Exception as e:
+            logger.error(f"Error getting local data for {endpoint}: {e}")
+            return None
+    
+    async def _fetch_remote_endpoint(self, endpoint: str) -> Optional[Dict[str, Any]]:
+        """Fetch data from a remote API endpoint with metrics tracking."""
         if not self.session:
             return None
             
@@ -116,12 +185,12 @@ class MetricsIntegrationService:
 # Global instance
 _metrics_service: Optional[MetricsIntegrationService] = None
 
-async def start_metrics_integration(base_url: str = "http://localhost:80", update_interval: int = 30):
+async def start_metrics_integration(base_url: str = "http://localhost:80", update_interval: int = 30, app_state=None):
     """Start the global metrics integration service."""
     global _metrics_service
     
     if _metrics_service is None:
-        _metrics_service = MetricsIntegrationService(base_url, update_interval)
+        _metrics_service = MetricsIntegrationService(base_url, update_interval, app_state)
         await _metrics_service.start()
 
 async def stop_metrics_integration():
diff --git a/src/seedcore/telemetry/server.py b/src/seedcore/telemetry/server.py
index 6024d52..f0ef1e5 100644
--- a/src/seedcore/telemetry/server.py
+++ b/src/seedcore/telemetry/server.py
@@ -29,6 +29,7 @@ from fastapi import FastAPI, Depends, HTTPException, Request  # type: ignore
 from collections import deque
 from typing import List, Dict, Any
 import time
+from contextlib import asynccontextmanager
 # import redis
 from ..telemetry.stats import StatsCollector
 from ..energy.api import energy_gradient_payload, _ledger
@@ -38,7 +39,7 @@ from ..control.slow_loop import slow_loop_update_roles, slow_loop_update_roles_s
 from ..control.mem_loop import adaptive_mem_update, estimate_memory_gradient, get_memory_metrics
 from ..organs.base import Organ
 from ..organs.registry import OrganRegistry
-from ..organs.organism_manager import organism_manager
+from ..organs import organism_manager as organism_manager_module
 from ..agents.base import Agent
 from ..agents import RayAgent, Tier0MemoryManager, tier0_manager
 from ..memory.system import SharedMemorySystem
@@ -67,7 +68,7 @@ from ..api.routers.tier0_router import router as tier0_router
 from ..api.routers.energy_router import router as energy_router
 from ..api.routers.holon_router import router as holon_router
 from ..config.ray_config import get_ray_config
-from ..utils.ray_utils import init_ray, get_ray_cluster_info, is_ray_available
+from ..utils.ray_connector import connect, is_connected, get_connection_info
 
 # NEW: Import DSPy cognitive core
 from ..agents.cognitive_core import (
@@ -110,7 +111,192 @@ ENERGY_WEIGHTS: EnergyWeights | None = None
 # In-memory Tier-1 cache (Mw) for demonstration
 mw_cache = {}  # This should be updated by your memory system as needed
 
-app = FastAPI()
+# ‚úÖ SOLUTION: Consolidate all startup logic into a single lifespan manager
+@asynccontextmanager
+async def lifespan(app: FastAPI):
+    # --- STARTUP LOGIC ---
+    logging.info("üöÄ FastAPI startup sequence initiated.")
+
+    # 1. Connect to Ray ONCE.
+    ray_ready = False
+    logging.info("   - Step 1: Connecting to Ray cluster...")
+    try:
+        connect()
+        logging.info("   - ‚úÖ Ray connection successful.")
+        
+        # Get detailed connection info
+        connection_info = get_connection_info()
+        logging.info(f"   - Ray connection info: {connection_info}")
+        
+        # Additional Ray diagnostics
+        try:
+            if ray.is_initialized():
+                runtime_context = ray.get_runtime_context()
+                logging.info(f"   - Ray runtime context: namespace={getattr(runtime_context, 'namespace', 'unknown')}")
+                
+                # Try to get cluster resources
+                try:
+                    cluster_resources = ray.cluster_resources()
+                    available_resources = ray.available_resources()
+                    logging.info(f"   - Cluster resources: {cluster_resources}")
+                    logging.info(f"   - Available resources: {available_resources}")
+                except Exception as e:
+                    logging.warning(f"   - Could not get cluster resources: {e}")
+                
+                # Try to list some actors
+                try:
+                    # Note: list_actors() might not work with Ray client connections
+                    logging.info("   - Ray client connection detected")
+                except Exception as e:
+                    logging.debug(f"   - Actor listing not available: {e}")
+            else:
+                logging.warning("   - Ray is not initialized after connect() call")
+        except Exception as e:
+            logging.warning(f"   - Ray diagnostics failed: {e}")
+        
+        # Verify Ray is fully connected and ready
+        if is_connected():
+            ray_ready = True
+            logging.info("   - ‚úÖ Ray connection verified and ready.")
+        else:
+            # Try waiting a bit for Ray to be fully ready
+            logging.info("   - ‚è≥ Ray not immediately ready, waiting up to 5 seconds...")
+            from ..utils.ray_connector import wait_for_ray_ready
+            if wait_for_ray_ready(max_wait_seconds=5):
+                ray_ready = True
+                logging.info("   - ‚úÖ Ray connection verified after waiting.")
+            else:
+                logging.warning("   - ‚ö†Ô∏è Ray connection verification failed, but continuing...")
+    except Exception as e:
+        logging.critical(f"   - ‚ùå Ray connection failed: {e}. Some features will be disabled.")
+
+    # 2. Initialize critical components that depend on Ray.
+    if ray_ready:
+        logging.info("   - Step 2: Initializing OrganismManager...")
+        try:
+            # Create the instance now that Ray is connected.
+            organism_manager_module.organism_manager = organism_manager_module.OrganismManager()
+            # Initialize it (this will create actors).
+            await organism_manager_module.organism_manager.initialize_organism()
+            app.state.organism = organism_manager_module.organism_manager
+            logging.info("   - ‚úÖ OrganismManager initialized.")
+        except Exception as e:
+            logging.error(f"   - ‚ùå Failed to initialize COA organism: {e}", exc_info=True)
+    else:
+        logging.warning("   - ‚ö†Ô∏è Skipping OrganismManager initialization due to Ray connection issues")
+        
+    # 3. Initialize memory system
+    logging.info("   - Step 3: Initializing Memory System...")
+    try:
+        global MEMORY_SYSTEM
+        MEMORY_SYSTEM = SharedMemorySystem()
+        app.state.mem = MEMORY_SYSTEM
+        logging.info("   - ‚úÖ Memory system initialized")
+    except Exception as e:
+        logging.error(f"   - ‚ùå Failed to initialize memory system: {e}")
+    
+    # 4. Initialize Holon Fabric
+    logging.info("   - Step 4: Initializing Holon Fabric...")
+    try:
+        await build_memory()
+        logging.info("   - ‚úÖ Holon Fabric initialized")
+    except Exception as e:
+        logging.error(f"   - ‚ùå Failed to initialize Holon Fabric: {e}")
+    
+    # 5. Start consolidator loop (depends on Ray for some operations)
+    logging.info("   - Step 5: Starting Consolidator Loop...")
+    try:
+        asyncio.create_task(start_consolidator())
+        logging.info("   - ‚úÖ Consolidator loop started")
+    except Exception as e:
+        logging.error(f"   - ‚ùå Failed to start consolidator loop: {e}")
+    
+    # 6. Initialize energy ledger
+    logging.info("   - Step 6: Initializing Energy Ledger...")
+    try:
+        store = EnergyLedgerStore({"enabled": True})
+        backend = (store.cfg.get("backend") or "").lower()
+        if backend in ("fs", "s3"):
+            logging.info(f"   - Rebuilding energy balances from ledger (backend={backend})")
+            store.rebuild_balances()
+        logging.info("   - ‚úÖ Energy ledger initialized")
+    except Exception as e:
+        logging.error(f"   - ‚ùå Failed to initialize energy ledger: {e}")
+    
+    # 7. Initialize ENERGY_WEIGHTS (depends on Ray for agent management)
+    if ray_ready:
+        logging.info("   - Step 7: Initializing Energy Weights...")
+        try:
+            global ENERGY_WEIGHTS
+            from ..agents.tier0_manager import Tier0MemoryManager
+            tier0_mgr = Tier0MemoryManager()
+            agent_ids = tier0_mgr.list_agents()
+            if agent_ids and ENERGY_WEIGHTS is None:
+                n = len(agent_ids)
+                # Start with zeros; learn from PairStats
+                ENERGY_WEIGHTS = EnergyWeights(
+                    W_pair=np.zeros((n, n), dtype=np.float32),
+                    W_hyper=np.zeros((0,), dtype=np.float32),
+                    alpha_entropy=0.1,
+                    lambda_reg=0.01,
+                    beta_mem=0.05,
+                )
+                ENERGY_WEIGHTS.project()
+                app.state.energy_weights = ENERGY_WEIGHTS
+            logging.info("   - ‚úÖ Energy weights initialized")
+        except Exception as e:
+            logging.error(f"   - ‚ùå Failed to initialize ENERGY_WEIGHTS: {e}")
+    else:
+        logging.warning("   - ‚ö†Ô∏è Skipping Energy Weights initialization due to Ray connection issues")
+    
+    # 8. Start metrics integration
+    logging.info("   - Step 8: Starting Metrics Integration...")
+    try:
+        from .metrics_integration import start_metrics_integration
+        base_url = os.getenv("SEEDCORE_API_ADDRESS", "localhost:8002")
+        if not base_url.startswith("http"):
+            base_url = f"http://{base_url}"
+        asyncio.create_task(start_metrics_integration(
+            base_url=base_url,
+            update_interval=30,
+            app_state=app.state  # Pass app state for local access
+        ))
+        logging.info("   - ‚úÖ Metrics integration started")
+    except Exception as e:
+        logging.error(f"   - ‚ùå Failed to start metrics integration: {e}")
+    
+    # 9. Sync counters
+    logging.info("   - Step 9: Syncing Counters...")
+    try:
+        await sync_counters()
+        logging.info("   - ‚úÖ Counters synced")
+    except Exception as e:
+        logging.error(f"   - ‚ùå Failed to sync counters: {e}")
+    
+    logging.info("‚úÖ FastAPI application startup complete.")
+    yield
+    
+    # --- SHUTDOWN LOGIC ---
+    logging.info("üõë FastAPI shutdown sequence initiated.")
+    
+    # Cleanup memory connections
+    try:
+        await cleanup_memory()
+        logging.info("   - ‚úÖ Memory cleanup completed")
+    except Exception as e:
+        logging.error(f"   - ‚ùå Memory cleanup failed: {e}")
+    
+    # Shutdown Ray
+    if ray.is_initialized():
+        ray.shutdown()
+        logging.info("   - ‚úÖ Ray shutdown completed")
+    
+    logging.info("‚úÖ FastAPI shutdown complete.")
+
+# Create FastAPI app with lifespan manager
+app = FastAPI(lifespan=lifespan)
+
+# Include all routers
 app.include_router(mfb_router)
 app.include_router(salience_router)
 app.include_router(organism_router)
@@ -201,130 +387,8 @@ RHO_CLIP: float = float(os.getenv("SEEDCORE_RHO_CLIP", "0.95"))
 BETA_TOK: float = float(os.getenv("SEEDCORE_BETA_TOK", "0.0"))
 PROMOTION_LTOT_CAP: float = float(os.getenv("SEEDCORE_PROMOTION_LTOT_CAP", "0.98"))
 
-@app.on_event("startup")
-async def startup_event():
-    """Initialize services on startup."""
-    global mw_cache, MEMORY_SYSTEM
-    
-    logging.info("üöÄ FastAPI startup event triggered")
-    logging.info("üîç Starting service initialization...")
-    
-    # Initialize memory system
-    try:
-        MEMORY_SYSTEM = SharedMemorySystem()
-        app.state.mem = MEMORY_SYSTEM
-        logging.info("‚úÖ Memory system initialized")
-    except Exception as e:
-        logging.error(f"‚ùå Failed to initialize memory system: {e}")
-    
-    # Initialize Ray with flexible configuration
-    try:
-        logging.info("üîç Checking Ray configuration...")
-        ray_config = get_ray_config()
-        logging.info(f"Ray config result: {ray_config}")
-        
-        if ray_config.is_configured():
-            logging.info(f"‚úÖ Ray is configured: {ray_config}")
-            
-            # Check if Ray is already initialized to avoid double initialization
-            if not ray.is_initialized():
-                logging.info("üîç Ray not initialized, attempting initialization...")
-                success = init_ray()
-                if success:
-                    logging.info("‚úÖ Ray initialization successful")
-                    cluster_info = get_ray_cluster_info()
-                    logging.info(f"Ray cluster info: {cluster_info}")
-                else:
-                    logging.error("‚ùå Ray initialization failed, continuing without Ray")
-            else:
-                logging.info("‚úÖ Ray is already initialized, skipping initialization")
-                cluster_info = get_ray_cluster_info()
-                logging.info(f"Ray cluster info: {cluster_info}")
-            
-            # Initialize the COA organism after Ray is ready
-            try:
-                logging.info("üöÄ Starting COA organism initialization...")
-                logging.info(f"üîç Organism manager state: initialized={organism_manager._initialized}")
-                logging.info(f"üîç Organism manager organs: {list(organism_manager.organs.keys())}")
-                logging.info(f"üîç Organism manager configs: {len(organism_manager.organ_configs)}")
-                logging.info(f"üîç Organism manager config details: {organism_manager.organ_configs}")
-                
-                # Check if organism manager has the right methods
-                logging.info(f"üîç Organism manager methods: {[method for method in dir(organism_manager) if not method.startswith('_')]}")
-                
-                await organism_manager.initialize_organism()
-                app.state.organism = organism_manager
-                logging.info("‚úÖ COA organism initialized successfully")
-                logging.info(f"üîç Final organism state: initialized={organism_manager._initialized}")
-                logging.info(f"üîç Final organism organs: {list(organism_manager.organs.keys())}")
-                
-                # Verify organs are accessible
-                for organ_id in organism_manager.organs:
-                    try:
-                        organ = organism_manager.organs[organ_id]
-                        status = ray.get(organ.get_status.remote())
-                        logging.info(f"‚úÖ Organ {organ_id} accessible: {status}")
-                    except Exception as e:
-                        logging.error(f"‚ùå Failed to access organ {organ_id}: {e}")
-                        
-            except Exception as e:
-                logging.error(f"‚ùå Failed to initialize COA organism: {e}")
-                logging.error(f"‚ùå Exception type: {type(e)}")
-                import traceback
-                logging.error(f"‚ùå Traceback: {traceback.format_exc()}")
-        else:
-            logging.warning("‚ö†Ô∏è Ray not configured, skipping Ray initialization")
-            logging.info(f"Ray config details: {ray_config}")
-    except Exception as e:
-        logging.error(f"‚ùå Error during Ray initialization: {e}")
-        import traceback
-        logging.error(f"‚ùå Traceback: {traceback.format_exc()}")
-    
-    # Start consolidator loop
-    try:
-        import asyncio
-        asyncio.create_task(start_consolidator())
-        logging.info("‚úÖ Consolidator loop started")
-    except Exception as e:
-        logging.error(f"‚ùå Failed to start consolidator loop: {e}")
-    
-    # Start consolidator loop
-    import asyncio
-    asyncio.create_task(start_consolidator())
-    logging.info("Consolidator loop started")
-
-    # Energy ledger: if FS/S3-like backend is configured, rebuild balances at startup
-    try:
-        store = EnergyLedgerStore({"enabled": True})
-        backend = (store.cfg.get("backend") or "").lower()
-        if backend in ("fs", "s3"):
-            logging.info("Rebuilding energy balances from ledger (backend=%s)", backend)
-            store.rebuild_balances()
-    except Exception:
-        logging.exception("Failed energy ledger rebuild on startup")
 
-    # Initialize ENERGY_WEIGHTS once agents are available
-    try:
-        global ENERGY_WEIGHTS
-        from ..agents.tier0_manager import Tier0MemoryManager
-        tier0_mgr = Tier0MemoryManager()
-        agent_ids = tier0_mgr.list_agents()
-        if agent_ids and ENERGY_WEIGHTS is None:
-            n = len(agent_ids)
-            # Start with zeros; learn from PairStats
-            ENERGY_WEIGHTS = EnergyWeights(
-                W_pair=np.zeros((n, n), dtype=np.float32),
-                W_hyper=np.zeros((0,), dtype=np.float32),
-                alpha_entropy=0.1,
-                lambda_reg=0.01,
-                beta_mem=0.05,
-            )
-            ENERGY_WEIGHTS.project()
-            app.state.energy_weights = ENERGY_WEIGHTS
-    except Exception:
-        logging.exception("Failed to initialize ENERGY_WEIGHTS")
 
-@app.on_event("startup")
 async def build_memory():
     """Initialize the Holon Fabric on server startup"""
     global holon_fabric
@@ -372,7 +436,6 @@ async def build_memory():
     
     print(f"Holon Fabric initialized with PG_DSN={pg_dsn}, NEO4J_URI={neo4j_uri}")
 
-@app.on_event("startup")
 async def start_consolidator():
     import asyncio, time
     async def loop():
@@ -397,7 +460,6 @@ async def start_consolidator():
     print("‚á¢ CONSOLIDATOR TASK SCHEDULED")
     asyncio.create_task(loop())
 
-@app.on_event("startup")
 async def sync_counters():
     import asyncpg  # type: ignore
     pg_dsn = os.getenv("PG_DSN")
@@ -414,7 +476,6 @@ async def sync_counters():
     finally:
         await c.close()
 
-@app.on_event("startup")
 async def start_metrics_integration():
     """Start the metrics integration service on startup."""
     try:
@@ -441,7 +502,6 @@ async def start_metrics_integration():
         logger = logging.getLogger(__name__)
         logger.error(f"Failed to start metrics integration: {e}")
 
-@app.on_event("shutdown")
 async def stop_metrics_integration():
     """Stop the metrics integration service on shutdown."""
     try:
@@ -455,7 +515,6 @@ async def stop_metrics_integration():
         logger = logging.getLogger(__name__)
         logger.error(f"Failed to stop metrics integration: {e}")
 
-@app.on_event("shutdown")
 async def cleanup_memory():
     """Cleanup connections on server shutdown"""
     global holon_fabric
@@ -661,7 +720,7 @@ async def energy_gradient():
         
         # Initialize Ray if not already done
         if not ray.is_initialized():
-            ray.init(address="auto", ignore_reinit_error=True)
+            ensure_ray_initialized()
         
         # Get Tier0 manager instance (create if needed)
         tier0_manager = Tier0MemoryManager()
@@ -920,7 +979,7 @@ def energy_calibrate():
         
         # Initialize Ray if not already done
         if not ray.is_initialized():
-            ray.init(address="auto", ignore_reinit_error=True)
+            ensure_ray_initialized()
         
         # Get Tier0 manager
         tier0_manager = Tier0MemoryManager()
@@ -1058,7 +1117,7 @@ def _build_energy_health_payload():
 
     # Initialize Ray if not already done
     if not ray.is_initialized():
-        ray.init(address="auto", ignore_reinit_error=True)
+        ensure_ray_initialized()
 
     # Get Tier0 manager for real agent data
     tier0_manager = Tier0MemoryManager()
@@ -1202,7 +1261,7 @@ def energy_monitor():
         
         # Initialize Ray if not already done
         if not ray.is_initialized():
-            ray.init(address="auto", ignore_reinit_error=True)
+            ensure_ray_initialized()
         
         # Get Tier0 manager
         tier0_manager = Tier0MemoryManager()
@@ -1430,7 +1489,7 @@ def system_status():
         
         # Initialize Ray if not already done
         if not ray.is_initialized():
-            ray.init(address="auto", ignore_reinit_error=True)
+            ensure_ray_initialized()
         
         # Get Tier0 manager for real agent data
         tier0_manager = Tier0MemoryManager()
@@ -1950,12 +2009,14 @@ async def ray_connect(request: dict):
         from ..config.ray_config import configure_ray_remote
         configure_ray_remote(host, port, password)
         
-        success = init_ray(force_reinit=True)
+        # Force reinit by calling connect() again (it's idempotent)
+        connect()
+        success = is_connected()
         if success:
             return {
                 "success": True,
                 "message": f"Connected to Ray at {host}:{port}",
-                "cluster_info": get_ray_cluster_info()
+                "cluster_info": get_connection_info()
             }
         else:
             return {"error": "Failed to connect to Ray cluster"}
diff --git a/src/seedcore/utils/ray_config.py b/src/seedcore/utils/ray_config.py
index 967ba77..2700ee2 100644
--- a/src/seedcore/utils/ray_config.py
+++ b/src/seedcore/utils/ray_config.py
@@ -1,6 +1,7 @@
 import os
 import logging
 from typing import Optional
+from .ray_utils import ensure_ray_initialized
 
 logger = logging.getLogger(__name__)
 
@@ -50,25 +51,13 @@ def init_ray_with_smart_defaults():
     - Head/worker pods: use "auto" or unset
     - Client pods: use derived or explicit RAY_ADDRESS
     """
-    import ray
-    
     ray_address = resolve_ray_address()
     namespace = get_ray_namespace()
     
-    if ray_address:
-        logger.info(f"Initializing Ray with address: {ray_address}, namespace: {namespace}")
-        ray.init(
-            address=ray_address,
-            namespace=namespace,
-            ignore_reinit_error=True
-        )
-    else:
-        logger.info("Initializing Ray locally (head/worker mode)")
-        ray.init(
-            address="auto",
-            namespace=namespace,
-            ignore_reinit_error=True
-        )
+    if not ensure_ray_initialized(ray_address=ray_address, ray_namespace=namespace):
+        raise RuntimeError(f"Failed to initialize Ray connection (address={ray_address}, namespace={namespace})")
+    
+    logger.info("‚úÖ Ray connection established successfully")
 
 def get_ray_serve_address() -> Optional[str]:
     """Get the Ray Serve address from environment variables."""
diff --git a/src/seedcore/utils/ray_utils.py b/src/seedcore/utils/ray_utils.py
index f0a9906..311714e 100644
--- a/src/seedcore/utils/ray_utils.py
+++ b/src/seedcore/utils/ray_utils.py
@@ -1,151 +1,85 @@
 """
 Ray utility functions for SeedCore.
-Provides flexible Ray initialization and connection management.
+Provides centralized, robust Ray initialization and connection management.
 """
 
 import os
-import socket
 import ray
 import logging
-from typing import Optional, Tuple
-from ..config.ray_config import get_ray_config, configure_ray_remote, configure_ray_local
+from typing import Optional
 
-logger = logging.getLogger(__name__)
+# Use a module-level flag for a fast path to avoid repeated checks.
+_RAY_INITIALIZED = False
 
+def ensure_ray_initialized(
+    ray_address: Optional[str] = None, 
+    ray_namespace: Optional[str] = "seedcore-dev",
+    force_reinit: bool = False
+) -> bool:
+    """
+    Connects to Ray if not already connected. Idempotent and environment-aware.
 
-def _can_connect_tcp(host: str, port: int, timeout_seconds: float = 0.5) -> bool:
-    """Return True if a TCP connection can be established to host:port within timeout."""
-    try:
-        with socket.create_connection((host, port), timeout=timeout_seconds):
-            return True
-    except Exception:
-        return False
-
-
-def _parse_ray_url(ray_url: str) -> Tuple[str, int]:
-    """Parse a ray://host:port URL into (host, port). Defaults port to 10001 if missing."""
-    try:
-        without_scheme = ray_url.replace("ray://", "", 1)
-        if ":" in without_scheme:
-            host_str, port_str = without_scheme.rsplit(":", 1)
-            return host_str, int(port_str)
-        return without_scheme, 10001
-    except Exception:
-        return ray_url, 10001
-
+    This is the single source of truth for all Ray connections.
 
-def resolve_ray_address() -> Optional[str]:
-    """Resolve a sensible default RAY_ADDRESS for both Kubernetes and Docker Compose.
-    
-    Priority order:
-    1) Respect explicit RAY_ADDRESS if set
-    2) Derive from RAY_HOST + RAY_PORT if available
-    3) Fall back to localhost for development
+    Args:
+        ray_address: Optional Ray cluster address to connect to
+        ray_namespace: Optional Ray namespace to use
+        force_reinit: If True, force reinitialize Ray even if already connected
+
+    Behavior:
+    1. If already connected and force_reinit=False, does nothing.
+    2. If force_reinit=True, shuts down existing connection and reconnects.
+    3. If RAY_ADDRESS env var is set, connects as a client to that address.
+    4. If RAY_ADDRESS is not set, connects with address="auto" to join the
+       existing cluster (for code running inside Ray pods) or start a local one.
     """
-    # Check for explicit RAY_ADDRESS first
-    explicit = os.getenv("RAY_ADDRESS")
-    if explicit:
-        logger.debug(f"Using explicit RAY_ADDRESS: {explicit}")
-        return explicit
+    global _RAY_INITIALIZED
     
-    # Check if we're in a head/worker pod (should not set RAY_ADDRESS)
-    # This is indicated by RAY_HOST being unset or pointing to localhost
-    ray_host = os.getenv("RAY_HOST")
-    if not ray_host or ray_host in ["localhost", "127.0.0.1"]:
-        logger.debug("In head/worker pod - RAY_HOST indicates local operation")
-        return "auto"
+    # Handle force reinit
+    if force_reinit and ray.is_initialized():
+        logging.info("Force reinit requested, shutting down existing Ray connection")
+        ray.shutdown()
+        _RAY_INITIALIZED = False
     
-    # Derive address from RAY_HOST + RAY_PORT
-    ray_port = os.getenv("RAY_PORT", "10001")
-    derived_address = f"ray://{ray_host}:{ray_port}"
-    logger.debug(f"Derived RAY_ADDRESS from RAY_HOST/RAY_PORT: {derived_address}")
-    return derived_address
+    if _RAY_INITIALIZED:
+        return True
 
+    if ray.is_initialized():
+        _RAY_INITIALIZED = True
+        return True
 
-def init_ray_with_smart_defaults() -> bool:
-    """Initialize Ray with smart defaults based on the new configuration pattern.
+    # Use the provided address, fall back to environment variable, then to "auto"
+    address_to_use = ray_address or os.getenv("RAY_ADDRESS") or "auto"
     
-    This function automatically handles the different pod roles:
-    - Head/worker pods: use "auto" or unset
-    - Client pods: use derived or explicit RAY_ADDRESS
-    """
+    logging.info(f"Ray not initialized. Attempting to connect with address='{address_to_use}'...")
+
     try:
-        # Check if Ray is already initialized
-        if ray.is_initialized():
-            logger.info("Ray is already initialized")
-            return True
-        
-        ray_address = resolve_ray_address()
-        namespace = os.getenv("RAY_NAMESPACE")
-        
-        if ray_address and ray_address != "auto":
-            logger.info(f"Initializing Ray with address: {ray_address}, namespace: {namespace}")
+        # Handle remote cluster connections with allow_multiple=True to prevent client conflicts
+        if address_to_use.startswith("ray://"):
             ray.init(
-                address=ray_address,
-                namespace=namespace,
-                ignore_reinit_error=True
+                address=address_to_use,
+                namespace=ray_namespace,
+                ignore_reinit_error=True,
+                logging_level=logging.WARNING,
+                allow_multiple=True,
             )
         else:
-            logger.info("Initializing Ray locally (head/worker mode)")
-            ray.init(
-                address="auto",
-                namespace=namespace,
-                ignore_reinit_error=True
-            )
-        
-        logger.info("Ray initialization successful")
-        return True
-        
-    except Exception as e:
-        logger.error(f"Failed to initialize Ray: {e}")
-        return False
-
-
-def init_ray(namespace: Optional[str] = None, ray_address: Optional[str] = None) -> bool:
-    """Initialize Ray with the specified namespace and address.
-    
-    Args:
-        namespace: Ray namespace to use (defaults to environment variable)
-        ray_address: Ray cluster address (optional, will derive from RAY_HOST/RAY_PORT if not provided)
-    
-    Returns:
-        True if Ray was initialized successfully, False otherwise
-    """
-    try:
-        if ray.is_initialized():
-            logger.info("‚úÖ Ray is already initialized")
-            return True
-        
-        # Get namespace from environment, default to "seedcore-dev" for consistency
-        if namespace is None:
-            namespace = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
-        
-        # Get Ray address from environment or derive from RAY_HOST/RAY_PORT
-        if ray_address is None:
-            ray_host = os.getenv("RAY_HOST", "seedcore-svc-head-svc")
-            ray_port = os.getenv("RAY_PORT", "10001")
-            ray_address = f"ray://{ray_host}:{ray_port}"
-        
-        # Always try to connect to the remote Ray cluster first
-        logger.info(f"Attempting to connect to Ray cluster at: {ray_address}")
-        try:
             ray.init(
-                address=ray_address,
+                address=address_to_use,
+                namespace=ray_namespace,
                 ignore_reinit_error=True,
-                namespace=namespace
+                logging_level=logging.WARNING,
             )
-            logger.info("‚úÖ Ray initialized successfully with remote address")
-        except Exception as e:
-            logger.warning(f"‚ö†Ô∏è Failed to connect to remote Ray cluster: {e}")
-            logger.warning("‚ö†Ô∏è Falling back to local Ray initialization")
-            ray.init(ignore_reinit_error=True, namespace=namespace)
-            logger.info("‚úÖ Ray initialized locally")
-        
-        logger.info("‚úÖ Ray initialized successfully")
+        _RAY_INITIALIZED = True
+        logging.info("Successfully connected to Ray.")
         return True
-        
     except Exception as e:
-        logger.error(f"‚ùå Failed to initialize Ray: {e}")
+        # Check if the error is about already being connected
+        if "already connected" in str(e).lower() or "allow_multiple" in str(e).lower():
+            logging.info("Ray is already connected to the cluster, marking as initialized")
+            _RAY_INITIALIZED = True
+            return True
+        logging.error(f"Failed to connect to Ray at address '{address_to_use}': {e}", exc_info=True)
         return False
 
 
@@ -154,9 +88,9 @@ def shutdown_ray() -> None:
     try:
         if ray.is_initialized():
             ray.shutdown()
-            logger.info("Ray shutdown successful")
+            logging.info("Ray shutdown successful")
     except Exception as e:
-        logger.error(f"Error during Ray shutdown: {e}")
+        logging.error(f"Error during Ray shutdown: {e}")
 
 
 def is_ray_available() -> bool:
@@ -182,7 +116,6 @@ def get_ray_cluster_info() -> dict:
             "cluster_resources": dict(resources),
             "available_resources": dict(available),
             "nodes": len(ray.nodes()),
-            "config": str(get_ray_config())
         }
     except Exception as e:
         return {"status": "error", "error": str(e)}
@@ -191,10 +124,8 @@ def get_ray_cluster_info() -> dict:
 def test_ray_connection() -> bool:
     """Test Ray connection with a simple task."""
     try:
-        if not ray.is_initialized():
-            logger.warning("Ray not initialized, attempting to initialize...")
-            if not init_ray():
-                return False
+        if not ensure_ray_initialized():
+            return False
         
         # Test with a simple remote function
         @ray.remote
@@ -202,53 +133,9 @@ def test_ray_connection() -> bool:
             return "Ray connection test successful"
         
         result = ray.get(test_function.remote())
-        logger.info(f"Ray connection test: {result}")
-        return True
-        
-    except Exception as e:
-        logger.error(f"Ray connection test failed: {e}")
-        return False 
-
-
-def ensure_ray_initialized(ray_address: Optional[str] = None, ray_namespace: Optional[str] = None) -> bool:
-    """Ensure Ray is initialized with the specified namespace and address.
-    
-    Args:
-        ray_address: Ray cluster address (optional, will derive from RAY_HOST/RAY_PORT if not provided)
-        ray_namespace: Ray namespace to use (defaults to environment variable)
-    
-    Returns:
-        True if Ray was initialized successfully, False otherwise
-    """
-    try:
-        if ray.is_initialized():
-            logger.info("‚úÖ Ray is already initialized")
-            return True
-        
-        # Get namespace from environment, default to "seedcore-dev" for consistency
-        if ray_namespace is None:
-            ray_namespace = os.getenv("RAY_NAMESPACE", os.getenv("SEEDCORE_NS", "seedcore-dev"))
-        
-        # Get Ray address from environment or derive from RAY_HOST/RAY_PORT
-        if ray_address is None:
-            ray_host = os.getenv("RAY_HOST", "seedcore-svc-head-svc")
-            ray_port = os.getenv("RAY_PORT", "10001")
-            ray_address = f"ray://{ray_host}:{ray_port}"
-        
-        # Always try to connect to the remote Ray cluster first
-        logger.info(f"Attempting to connect to Ray cluster at: {ray_address}")
-        try:
-            ray.init(address=ray_address, ignore_reinit_error=True, namespace=ray_namespace)
-            logger.info("‚úÖ Ray initialized successfully with remote address")
-        except Exception as e:
-            logger.warning(f"‚ö†Ô∏è Failed to connect to remote Ray cluster: {e}")
-            logger.warning("‚ö†Ô∏è Falling back to local Ray initialization")
-            ray.init(ignore_reinit_error=True, namespace=ray_namespace)
-            logger.info("‚úÖ Ray initialized locally")
-        
-        logger.info("‚úÖ Ray initialized successfully")
+        logging.info(f"Ray connection test: {result}")
         return True
         
     except Exception as e:
-        logger.error(f"‚ùå Failed to initialize Ray: {e}")
+        logging.error(f"Ray connection test failed: {e}")
         return False 
\ No newline at end of file
